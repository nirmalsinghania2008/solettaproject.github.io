<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Soletta: OIC Client</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Soletta
   </div>
   <div id="projectbrief">Framework for making IoT devices</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">OIC Client<div class="ingroups"><a class="el" href="group__Comms.html">Communication Modules</a> &raquo; <a class="el" href="group__OIC.html">Open Interconnect Consortium</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Routines to create clients talking OIC protocol.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsol__oic__client.html">sol_oic_client</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure defining an oic client.  <a href="structsol__oic__client.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsol__oic__resource.html">sol_oic_resource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure defining an oic resource.  <a href="structsol__oic__resource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gabc1fe94c938062131c997ced8b67eed5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__oic__client.html#gabc1fe94c938062131c997ced8b67eed5">sol_oic_client_find_resource</a> (struct <a class="el" href="structsol__oic__client.html">sol_oic_client</a> *client, struct <a class="el" href="structsol__network__link__addr.html">sol_network_link_addr</a> *cliaddr, const char *resource_type, bool(*resource_found_cb)(struct <a class="el" href="structsol__oic__client.html">sol_oic_client</a> *cli, struct <a class="el" href="structsol__oic__resource.html">sol_oic_resource</a> *res, void *data), void *data)</td></tr>
<tr class="memdesc:gabc1fe94c938062131c997ced8b67eed5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a discovevery packet to find resources.  <a href="#gabc1fe94c938062131c997ced8b67eed5">More...</a><br /></td></tr>
<tr class="separator:gabc1fe94c938062131c997ced8b67eed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga126014c3d849d825a01edc38dede54d2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__oic__client.html#ga126014c3d849d825a01edc38dede54d2">sol_oic_client_get_server_info</a> (struct <a class="el" href="structsol__oic__client.html">sol_oic_client</a> *client, struct <a class="el" href="structsol__oic__resource.html">sol_oic_resource</a> *resource, void(*info_received_cb)(struct <a class="el" href="structsol__oic__client.html">sol_oic_client</a> *cli, const struct <a class="el" href="structsol__oic__server__information.html">sol_oic_server_information</a> *info, void *data), void *data)</td></tr>
<tr class="memdesc:ga126014c3d849d825a01edc38dede54d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve server information.  <a href="#ga126014c3d849d825a01edc38dede54d2">More...</a><br /></td></tr>
<tr class="separator:ga126014c3d849d825a01edc38dede54d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga294b751e0b63bac4119a2f07e4942b54"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__oic__client.html#ga294b751e0b63bac4119a2f07e4942b54">sol_oic_client_resource_non_confirmable_request</a> (struct <a class="el" href="structsol__oic__client.html">sol_oic_client</a> *client, struct <a class="el" href="structsol__oic__resource.html">sol_oic_resource</a> *res, <a class="el" href="group__CoAP.html#ga56f995e7cd29ac0aa8cf26d1135612e3">sol_coap_method_t</a> method, bool(*fill_repr_map)(void *data, struct <a class="el" href="structsol__oic__map__writer.html">sol_oic_map_writer</a> *repr_map), void *fill_repr_map_data, void(*callback)(struct <a class="el" href="structsol__oic__client.html">sol_oic_client</a> *cli, const struct <a class="el" href="structsol__network__link__addr.html">sol_network_link_addr</a> *addr, const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> *href, const struct <a class="el" href="structsol__oic__map__reader.html">sol_oic_map_reader</a> *repr_vec, void *data), void *callback_data)</td></tr>
<tr class="memdesc:ga294b751e0b63bac4119a2f07e4942b54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a request packet to server for specific <em>resource</em>, using non-confirmable packets.  <a href="#ga294b751e0b63bac4119a2f07e4942b54">More...</a><br /></td></tr>
<tr class="separator:ga294b751e0b63bac4119a2f07e4942b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga539903f372883d8dff736d95f7860ae1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__oic__client.html#ga539903f372883d8dff736d95f7860ae1">sol_oic_client_resource_request</a> (struct <a class="el" href="structsol__oic__client.html">sol_oic_client</a> *client, struct <a class="el" href="structsol__oic__resource.html">sol_oic_resource</a> *res, <a class="el" href="group__CoAP.html#ga56f995e7cd29ac0aa8cf26d1135612e3">sol_coap_method_t</a> method, bool(*fill_repr_map)(void *data, struct <a class="el" href="structsol__oic__map__writer.html">sol_oic_map_writer</a> *repr_map), void *fill_repr_map_data, void(*callback)(struct <a class="el" href="structsol__oic__client.html">sol_oic_client</a> *cli, const struct <a class="el" href="structsol__network__link__addr.html">sol_network_link_addr</a> *addr, const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> *href, const struct <a class="el" href="structsol__oic__map__reader.html">sol_oic_map_reader</a> *repr_vec, void *data), void *callback_data)</td></tr>
<tr class="memdesc:ga539903f372883d8dff736d95f7860ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a request packet to server for specific <em>resource</em>.  <a href="#ga539903f372883d8dff736d95f7860ae1">More...</a><br /></td></tr>
<tr class="separator:ga539903f372883d8dff736d95f7860ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0af02506aefc62d59b0e7fde771cd4d6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__oic__client.html#ga0af02506aefc62d59b0e7fde771cd4d6">sol_oic_client_resource_set_observable</a> (struct <a class="el" href="structsol__oic__client.html">sol_oic_client</a> *client, struct <a class="el" href="structsol__oic__resource.html">sol_oic_resource</a> *res, void(*callback)(struct <a class="el" href="structsol__oic__client.html">sol_oic_client</a> *cli, const struct <a class="el" href="structsol__network__link__addr.html">sol_network_link_addr</a> *addr, const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> *href, const struct <a class="el" href="structsol__oic__map__reader.html">sol_oic_map_reader</a> *repr_map, void *data), void *data, bool observe)</td></tr>
<tr class="memdesc:ga0af02506aefc62d59b0e7fde771cd4d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this resource as observable for this client.  <a href="#ga0af02506aefc62d59b0e7fde771cd4d6">More...</a><br /></td></tr>
<tr class="separator:ga0af02506aefc62d59b0e7fde771cd4d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga068d8415d48f8cc9705f76ae67b170f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__oic__client.html#ga068d8415d48f8cc9705f76ae67b170f1">sol_oic_client_resource_set_observable_non_confirmable</a> (struct <a class="el" href="structsol__oic__client.html">sol_oic_client</a> *client, struct <a class="el" href="structsol__oic__resource.html">sol_oic_resource</a> *res, void(*callback)(struct <a class="el" href="structsol__oic__client.html">sol_oic_client</a> *cli, const struct <a class="el" href="structsol__network__link__addr.html">sol_network_link_addr</a> *addr, const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> *href, const struct <a class="el" href="structsol__oic__map__reader.html">sol_oic_map_reader</a> *repr_map, void *data), void *data, bool observe)</td></tr>
<tr class="memdesc:ga068d8415d48f8cc9705f76ae67b170f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this resource as observable for this client, using non-confirmable packets.  <a href="#ga068d8415d48f8cc9705f76ae67b170f1">More...</a><br /></td></tr>
<tr class="separator:ga068d8415d48f8cc9705f76ae67b170f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac973947ad4d0512072722aa94b215d43"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structsol__oic__resource.html">sol_oic_resource</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__oic__client.html#gac973947ad4d0512072722aa94b215d43">sol_oic_resource_ref</a> (struct <a class="el" href="structsol__oic__resource.html">sol_oic_resource</a> *r)</td></tr>
<tr class="memdesc:gac973947ad4d0512072722aa94b215d43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a reference of the given server.  <a href="#gac973947ad4d0512072722aa94b215d43">More...</a><br /></td></tr>
<tr class="separator:gac973947ad4d0512072722aa94b215d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac30349b73208dcd49cc2cf322b491ecd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__oic__client.html#gac30349b73208dcd49cc2cf322b491ecd">sol_oic_resource_unref</a> (struct <a class="el" href="structsol__oic__resource.html">sol_oic_resource</a> *r)</td></tr>
<tr class="memdesc:gac30349b73208dcd49cc2cf322b491ecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a reference from the given resource.  <a href="#gac30349b73208dcd49cc2cf322b491ecd">More...</a><br /></td></tr>
<tr class="separator:gac30349b73208dcd49cc2cf322b491ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Routines to create clients talking OIC protocol. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gabc1fe94c938062131c997ced8b67eed5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sol_oic_client_find_resource </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsol__oic__client.html">sol_oic_client</a> *&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsol__network__link__addr.html">sol_network_link_addr</a> *&#160;</td>
          <td class="paramname"><em>cliaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>resource_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(struct <a class="el" href="structsol__oic__client.html">sol_oic_client</a> *cli, struct <a class="el" href="structsol__oic__resource.html">sol_oic_resource</a> *res, void *data)&#160;</td>
          <td class="paramname"><em>resource_found_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a discovevery packet to find resources. </p>
<p>Sends a discovery packet to the destination address especified by <em>cliaddr</em>, which may be a multicast address for discovery purposes.</p>
<p>When a response is received, the function <em>resource_found_cb</em> will be called. Note that multiple responses can be received for this request. As long as this function returns <code>true</code>, <em>client</em> will continue waiting for more responses. When the function returns <code>false</code>, the internal response handler will be freed and any new replies that arrive for this request will be ignored. After internal timeout is reached <em>resource_found_cb</em> will be called with <code>NULL</code> <em>oic_res</em>. The same behavior is expected for <em>resource_found_cb</em> return, if resource_found_cb returns <code>true</code>, <em>client</em> will continue waiting responses until next timeout. If <em>resource_found_cb</em> returns <code>false</code>, <em>client</em> will terminate response waiting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>An oic client instance. </td></tr>
    <tr><td class="paramname">cliaddr</td><td>The address of the server that contains the desired resource. May be a multicast address if it is desired to look for resources in multiple servers. </td></tr>
    <tr><td class="paramname">resource_type</td><td>A string representation of the type of the desired resource. </td></tr>
    <tr><td class="paramname">resource_found_cb</td><td>Callback to be called when a resource is found or when timeout is reached. Parameter cli is the <a class="el" href="structsol__oic__client.html" title="Structure defining an oic client. ">sol_oic_client</a> used to perform the request, res is the resource that was discovered and data is a pointer to the user's data parameter. </td></tr>
    <tr><td class="paramname">data</td><td>A pointer to user's data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if packet was successfully sent. False otherwise. </dd></dl>

<p>Referenced by <a class="el" href="oic-client_8c.html#a0ddf1224851353fc92bfbff6f499fa97">main()</a>.</p>

</div>
</div>
<a class="anchor" id="ga126014c3d849d825a01edc38dede54d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sol_oic_client_get_server_info </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsol__oic__client.html">sol_oic_client</a> *&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsol__oic__resource.html">sol_oic_resource</a> *&#160;</td>
          <td class="paramname"><em>resource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(struct <a class="el" href="structsol__oic__client.html">sol_oic_client</a> *cli, const struct <a class="el" href="structsol__oic__server__information.html">sol_oic_server_information</a> *info, void *data)&#160;</td>
          <td class="paramname"><em>info_received_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve server information. </p>
<p>Sends a packet to server asking for server information defined at <a class="el" href="structsol__oic__server__information.html">sol_oic_server_information</a>.</p>
<p>When a response is received, the function <em>info_received_cb</em> will be called. After internal timeout is reached <em>info_received_cb</em> will be called with <code>NULL</code> <em>info</em> and any clean up can be performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>An oic client instance. </td></tr>
    <tr><td class="paramname">resource</td><td>The resource that is going to receive the request. </td></tr>
    <tr><td class="paramname">info_received_cb</td><td>Callback to be called when response is received or when timeout is reached. Parameter cli is the <a class="el" href="structsol__oic__client.html" title="Structure defining an oic client. ">sol_oic_client</a> used to perform the request, info is the <a class="el" href="structsol__oic__server__information.html">sol_oic_server_information</a> structure with server info data, data is a pointer to user's data parameter. </td></tr>
    <tr><td class="paramname">data</td><td>A pointer to user's data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if packet was successfully sent. False otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga294b751e0b63bac4119a2f07e4942b54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sol_oic_client_resource_non_confirmable_request </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsol__oic__client.html">sol_oic_client</a> *&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsol__oic__resource.html">sol_oic_resource</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CoAP.html#ga56f995e7cd29ac0aa8cf26d1135612e3">sol_coap_method_t</a>&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(void *data, struct <a class="el" href="structsol__oic__map__writer.html">sol_oic_map_writer</a> *repr_map)&#160;</td>
          <td class="paramname"><em>fill_repr_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>fill_repr_map_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(struct <a class="el" href="structsol__oic__client.html">sol_oic_client</a> *cli, const struct <a class="el" href="structsol__network__link__addr.html">sol_network_link_addr</a> *addr, const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> *href, const struct <a class="el" href="structsol__oic__map__reader.html">sol_oic_map_reader</a> *repr_vec, void *data)&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callback_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a request packet to server for specific <em>resource</em>, using non-confirmable packets. </p>
<p>Send a CoAP non-confirmable request packet to server that contains the <em>resource</em> and wait for a response. When the response arrives, <em>callback</em> will be called.</p>
<p>The only difference from <a class="el" href="group__oic__client.html#ga539903f372883d8dff736d95f7860ae1">sol_oic_client_resource_request()</a> to this function is that it uses CoAP non-confirmable packets to make the request.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>An oic client instance. </td></tr>
    <tr><td class="paramname">res</td><td>The resource that is going to receive the request. </td></tr>
    <tr><td class="paramname">method</td><td>The coap request method as documented in <a class="el" href="group__CoAP.html#ga56f995e7cd29ac0aa8cf26d1135612e3">sol_coap_method_t</a>. </td></tr>
    <tr><td class="paramname">fill_repr_map</td><td>A callback to be called to fill the request data. Parameter <em>data</em> is a pointer to user's <em>fill_repr_map_data</em> and <em>repr_map</em> is a handler to write data to request packet. Use <a class="el" href="group__OIC.html#ga4064c07a0cdb9ad128b0084520840034">sol_oic_map_append()</a> to append data to <em>repr_map</em>. </td></tr>
    <tr><td class="paramname">fill_repr_map_data</td><td>User's data to be passed to <em>fill_repr_map</em>. </td></tr>
    <tr><td class="paramname">callback</td><td>Callback to be called when a response from this request arrives. Parameter <em>cli</em> is the <em>client</em> used to perform the request, <em>addr</em> is the address of the server, <em>href</em> is the path of the resource and repr_vec is a handler to access data from response, using <a class="el" href="group__OIC.html#gaedb2a91af497e87dfa0c506eb1bd6ecd">SOL_OIC_MAP_LOOP()</a> macro. <em>data</em> is the user's <em>callback_data</em>. </td></tr>
    <tr><td class="paramname">callback_data</td><td>User's data to be passed to <em>callback</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if packet was successfully sent. False otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga539903f372883d8dff736d95f7860ae1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sol_oic_client_resource_request </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsol__oic__client.html">sol_oic_client</a> *&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsol__oic__resource.html">sol_oic_resource</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CoAP.html#ga56f995e7cd29ac0aa8cf26d1135612e3">sol_coap_method_t</a>&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(void *data, struct <a class="el" href="structsol__oic__map__writer.html">sol_oic_map_writer</a> *repr_map)&#160;</td>
          <td class="paramname"><em>fill_repr_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>fill_repr_map_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(struct <a class="el" href="structsol__oic__client.html">sol_oic_client</a> *cli, const struct <a class="el" href="structsol__network__link__addr.html">sol_network_link_addr</a> *addr, const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> *href, const struct <a class="el" href="structsol__oic__map__reader.html">sol_oic_map_reader</a> *repr_vec, void *data)&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callback_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a request packet to server for specific <em>resource</em>. </p>
<p>Send a CoAP confirmable request packet to server that contains the <em>resource</em> and wait for a response. When the response arrives, <em>callback</em> will be called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>An oic client instance. </td></tr>
    <tr><td class="paramname">res</td><td>The resource that is going to receive the request. </td></tr>
    <tr><td class="paramname">method</td><td>The coap request method as documented in <a class="el" href="group__CoAP.html#ga56f995e7cd29ac0aa8cf26d1135612e3">sol_coap_method_t</a>. </td></tr>
    <tr><td class="paramname">fill_repr_map</td><td>A callback to be called to fill the request data. Parameter <em>data</em> is a pointer to user's <em>fill_repr_map_data</em> and <em>repr_map</em> is a handler to write data to request packet. Use <a class="el" href="group__OIC.html#ga4064c07a0cdb9ad128b0084520840034">sol_oic_map_append()</a> to append data to <em>repr_map</em>. </td></tr>
    <tr><td class="paramname">fill_repr_map_data</td><td>User's data to be passed to <em>fill_repr_map</em>. </td></tr>
    <tr><td class="paramname">callback</td><td>Callback to be called when a response from this request arrives. Parameter <em>cli</em> is the <em>client</em> used to perform the request, <em>addr</em> is the address of the server, <em>href</em> is the path of the resource and repr_vec is a handler to access data from response, using <a class="el" href="group__OIC.html#gaedb2a91af497e87dfa0c506eb1bd6ecd">SOL_OIC_MAP_LOOP()</a> macro. <em>data</em> is the user's <em>callback_data</em>. </td></tr>
    <tr><td class="paramname">callback_data</td><td>User's data to be passed to <em>callback</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if packet was successfully sent. False otherwise. </dd></dl>

<p>Referenced by <a class="el" href="oic-client_8c.html#a6965d683fc742cf243b2e73b9f971952">found_resource()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0af02506aefc62d59b0e7fde771cd4d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sol_oic_client_resource_set_observable </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsol__oic__client.html">sol_oic_client</a> *&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsol__oic__resource.html">sol_oic_resource</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(struct <a class="el" href="structsol__oic__client.html">sol_oic_client</a> *cli, const struct <a class="el" href="structsol__network__link__addr.html">sol_network_link_addr</a> *addr, const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> *href, const struct <a class="el" href="structsol__oic__map__reader.html">sol_oic_map_reader</a> *repr_map, void *data)&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>observe</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set this resource as observable for this client. </p>
<p>If server providing the <em>resource</em> supports observing clients, sends a request to server asking it to add <em>client</em> to its observing list. Clients in observation receives notifications when server status changes. When a notification is received by <em>client</em>, <em>callback</em> will be called. If the <em>resource</em> is not observable, <em>client</em> will emulate the observing behavior using a pooling strategy, so <em>callback</em> will be notified with server changes from time to time.</p>
<p>As long as the <em>callback</em> function returns <code>true</code>, <em>client</em> will continue waiting for notifications. When the function returns <code>false</code>, the internal response handler will be freed and any new replies that arrive for this request will be ignored. If pooling is being performed, it will be cancelled. If server is notifying the <em>client</em>, a request packet to ask server to unobserve this <em>client</em> will be sent.</p>
<p>When user wants to stop observing the server, just return <code>false</code> in <em>callback</em> or call <a class="el" href="group__oic__client.html#ga0af02506aefc62d59b0e7fde771cd4d6">sol_oic_client_resource_set_observable()</a> with <em>observe</em> as <code>false</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>An oic client instance. </td></tr>
    <tr><td class="paramname">res</td><td>The resource that is going to be observed </td></tr>
    <tr><td class="paramname">callback</td><td>A callback to be called when notification responses arrive. Parameter <em>cli</em> is the <em>client</em> used to perform the request, <em>addr</em> is the address of the server, <em>href</em> is the path of the resource being observed, <em>repr_map</em> is the data from the notification and <em>data</em> is a pointer to user's data. To extract data from <em>repr_map</em> use <a class="el" href="group__OIC.html#gaedb2a91af497e87dfa0c506eb1bd6ecd">SOL_OIC_MAP_LOOP()</a> macro. </td></tr>
    <tr><td class="paramname">data</td><td>A pointer to user's data. </td></tr>
    <tr><td class="paramname">observe</td><td>If server will be obeserved or unobserved.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if packet was successfully sent. False otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga068d8415d48f8cc9705f76ae67b170f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sol_oic_client_resource_set_observable_non_confirmable </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsol__oic__client.html">sol_oic_client</a> *&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsol__oic__resource.html">sol_oic_resource</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(struct <a class="el" href="structsol__oic__client.html">sol_oic_client</a> *cli, const struct <a class="el" href="structsol__network__link__addr.html">sol_network_link_addr</a> *addr, const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> *href, const struct <a class="el" href="structsol__oic__map__reader.html">sol_oic_map_reader</a> *repr_map, void *data)&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>observe</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set this resource as observable for this client, using non-confirmable packets. </p>
<p>If server providing the <em>resource</em> supports observing clients, sends a request to server asking it to add <em>client</em> to its observing list. Clients in observation receives notifications when server status changes. When a notification is received by <em>client</em>, <em>callback</em> will be called. If the <em>resource</em> is not observable, <em>client</em> will emulate the observing behavior using a pooling strategy, so <em>callback</em> will be notified with server changes from time to time.</p>
<p>As long as the <em>callback</em> function returns <code>true</code>, <em>client</em> will continue waiting for notifications. When the function returns <code>false</code>, the internal response handler will be freed and any new replies that arrive for this request will be ignored. If pooling is being performed, it will be cancelled. If server is notifying the <em>client</em>, a request packet to ask server to unobserve this <em>client</em> will be sent.</p>
<p>When user wants to stop observing the server, just return <code>false</code> in <em>callback</em> or call <a class="el" href="group__oic__client.html#ga0af02506aefc62d59b0e7fde771cd4d6">sol_oic_client_resource_set_observable()</a> with <em>observe</em> as <code>false</code>.</p>
<p>The only difference from <a class="el" href="group__oic__client.html#ga0af02506aefc62d59b0e7fde771cd4d6">sol_oic_client_resource_set_observable()</a> to this function is that it uses CoAP non-confirmable packets to make the request.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>An oic client instance. </td></tr>
    <tr><td class="paramname">res</td><td>The resource that is going to be observed </td></tr>
    <tr><td class="paramname">callback</td><td>A callback to be called when notification responses arrive. Parameter <em>cli</em> is the <em>client</em> used to perform the request, <em>addr</em> is the address of the server, <em>href</em> is the path of the resource being observed, <em>repr_map</em> is the data from the notification and <em>data</em> is a pointer to user's data. To extract data from <em>repr_map</em> use <a class="el" href="group__OIC.html#gaedb2a91af497e87dfa0c506eb1bd6ecd">SOL_OIC_MAP_LOOP()</a> macro. </td></tr>
    <tr><td class="paramname">data</td><td>A pointer to user's data. </td></tr>
    <tr><td class="paramname">observe</td><td>If server will be obeserved or unobserved.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if packet was successfully sent. False otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="gac973947ad4d0512072722aa94b215d43"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structsol__oic__resource.html">sol_oic_resource</a>* sol_oic_resource_ref </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsol__oic__resource.html">sol_oic_resource</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a reference of the given server. </p>
<p>Increment the reference count of the resource, if it's valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>The resource to reference.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The same resource, with refcount increased, or NULL if invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="gac30349b73208dcd49cc2cf322b491ecd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sol_oic_resource_unref </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsol__oic__resource.html">sol_oic_resource</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release a reference from the given resource. </p>
<p>When the last reference is released, the resource with it will be freed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>The resource to release. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
