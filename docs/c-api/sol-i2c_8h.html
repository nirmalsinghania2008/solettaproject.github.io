<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Soletta: src/lib/io/include/sol-i2c.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Soletta
   </div>
   <div id="projectbrief">Framework for making IoT devices</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_bc32ed4505d91e3d9150841baf9e9179.html">src</a></li><li class="navelem"><a class="el" href="dir_bf9fb35a08b1d196a37cadbabea85462.html">lib</a></li><li class="navelem"><a class="el" href="dir_cef735afa444e07d297ce7e0912cb4f4.html">io</a></li><li class="navelem"><a class="el" href="dir_3bc1e84437a0be1f9a382074675de1da.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">sol-i2c.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>These routines are used for I2C access under Soletta.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdbool.h&gt;</code><br/>
<code>#include &lt;stdint.h&gt;</code><br/>
<code>#include &lt;sys/types.h&gt;</code><br/>
<code>#include &lt;<a class="el" href="sol-macros_8h_source.html">sol-macros.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="sol-buffer_8h_source.html">sol-buffer.h</a>&gt;</code><br/>
</div>
<p><a href="sol-i2c_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="memitem:a2a27a2238a08a352353426df1ff440d6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol-i2c_8h.html#a2a27a2238a08a352353426df1ff440d6">sol_i2c_speed</a> { <br/>
&#160;&#160;<a class="el" href="sol-i2c_8h.html#a2a27a2238a08a352353426df1ff440d6aae7266bcbc836ae6013609abeb7a1d3c">SOL_I2C_SPEED_10KBIT</a> = 0, 
<a class="el" href="sol-i2c_8h.html#a2a27a2238a08a352353426df1ff440d6a6f3c4ddd9f4a729c90aee29a8c806752">SOL_I2C_SPEED_100KBIT</a>, 
<a class="el" href="sol-i2c_8h.html#a2a27a2238a08a352353426df1ff440d6aa46e872c069c9605b2eb8b9313a04b4b">SOL_I2C_SPEED_400KBIT</a>, 
<a class="el" href="sol-i2c_8h.html#a2a27a2238a08a352353426df1ff440d6a15f9d8ee77c27344e5d3bf8d43c474d9">SOL_I2C_SPEED_1MBIT</a>, 
<br/>
&#160;&#160;<a class="el" href="sol-i2c_8h.html#a2a27a2238a08a352353426df1ff440d6a12945c5903700e30972b38637f8c1ff4">SOL_I2C_SPEED_3MBIT_400KBIT</a>
<br/>
 }</td></tr>
<tr class="separator:a2a27a2238a08a352353426df1ff440d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f1c39293b17fde011fa146985f51bf"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structsol__i2c.html">sol_i2c</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol-i2c_8h.html#a90f1c39293b17fde011fa146985f51bf">sol_i2c_open_raw</a> (uint8_t bus, enum <a class="el" href="sol-i2c_8h.html#a2a27a2238a08a352353426df1ff440d6">sol_i2c_speed</a> speed) <a class="el" href="group__HTTP.html#gada0c871b155cd2df41360f2eb942990c">SOL_ATTR_WARN_UNUSED_RESULT</a></td></tr>
<tr class="separator:a90f1c39293b17fde011fa146985f51bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43d88e4d8e1bafbcfdc36cbfe3928f5a"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structsol__i2c.html">sol_i2c</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol-i2c_8h.html#a43d88e4d8e1bafbcfdc36cbfe3928f5a">sol_i2c_open</a> (uint8_t bus, enum <a class="el" href="sol-i2c_8h.html#a2a27a2238a08a352353426df1ff440d6">sol_i2c_speed</a> speed) <a class="el" href="group__HTTP.html#gada0c871b155cd2df41360f2eb942990c">SOL_ATTR_WARN_UNUSED_RESULT</a></td></tr>
<tr class="separator:a43d88e4d8e1bafbcfdc36cbfe3928f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abca31deed9d3eb838a7e038aa7d4b300"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol-i2c_8h.html#abca31deed9d3eb838a7e038aa7d4b300">sol_i2c_close</a> (struct <a class="el" href="structsol__i2c.html">sol_i2c</a> *i2c)</td></tr>
<tr class="separator:abca31deed9d3eb838a7e038aa7d4b300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf697f94177ca536843244fe34c3c1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol-i2c_8h.html#abaf697f94177ca536843244fe34c3c1c">sol_i2c_close_raw</a> (struct <a class="el" href="structsol__i2c.html">sol_i2c</a> *i2c)</td></tr>
<tr class="separator:abaf697f94177ca536843244fe34c3c1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae778e276d19675d0113711629a9cb40a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol-i2c_8h.html#ae778e276d19675d0113711629a9cb40a">sol_i2c_set_slave_address</a> (struct <a class="el" href="structsol__i2c.html">sol_i2c</a> *i2c, uint8_t slave_address)</td></tr>
<tr class="separator:ae778e276d19675d0113711629a9cb40a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afba3760a7aa59217fd08035b07f4296b"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol-i2c_8h.html#afba3760a7aa59217fd08035b07f4296b">sol_i2c_get_slave_address</a> (struct <a class="el" href="structsol__i2c.html">sol_i2c</a> *i2c)</td></tr>
<tr class="separator:afba3760a7aa59217fd08035b07f4296b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07bd4788ce4eb74e1d0e395a98e5c4be"><td class="memItemLeft" align="right" valign="top">struct sol_i2c_pending *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol-i2c_8h.html#a07bd4788ce4eb74e1d0e395a98e5c4be">sol_i2c_write_quick</a> (struct <a class="el" href="structsol__i2c.html">sol_i2c</a> *i2c, bool rw, void(*write_quick_cb)(void *cb_data, struct <a class="el" href="structsol__i2c.html">sol_i2c</a> *i2c, ssize_t status), const void *cb_data)</td></tr>
<tr class="separator:a07bd4788ce4eb74e1d0e395a98e5c4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfbc27121339b1e4c422fdab483d9e71"><td class="memItemLeft" align="right" valign="top">struct sol_i2c_pending *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol-i2c_8h.html#acfbc27121339b1e4c422fdab483d9e71">sol_i2c_read</a> (struct <a class="el" href="structsol__i2c.html">sol_i2c</a> *i2c, uint8_t *data, size_t count, void(*read_cb)(void *cb_data, struct <a class="el" href="structsol__i2c.html">sol_i2c</a> *i2c, uint8_t *data, ssize_t status), const void *cb_data)</td></tr>
<tr class="separator:acfbc27121339b1e4c422fdab483d9e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af328baecae0e32b78fe133d67273ed9a"><td class="memItemLeft" align="right" valign="top">struct sol_i2c_pending *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol-i2c_8h.html#af328baecae0e32b78fe133d67273ed9a">sol_i2c_write</a> (struct <a class="el" href="structsol__i2c.html">sol_i2c</a> *i2c, uint8_t *data, size_t count, void(*write_cb)(void *cb_data, struct <a class="el" href="structsol__i2c.html">sol_i2c</a> *i2c, uint8_t *data, ssize_t status), const void *cb_data)</td></tr>
<tr class="separator:af328baecae0e32b78fe133d67273ed9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a022d31e09906af1a1934a03c49f41315"><td class="memItemLeft" align="right" valign="top">struct sol_i2c_pending *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol-i2c_8h.html#a022d31e09906af1a1934a03c49f41315">sol_i2c_read_register</a> (struct <a class="el" href="structsol__i2c.html">sol_i2c</a> *i2c, uint8_t reg, uint8_t *data, size_t count, void(*read_reg_cb)(void *cb_data, struct <a class="el" href="structsol__i2c.html">sol_i2c</a> *i2c, uint8_t reg, uint8_t *data, ssize_t status), const void *cb_data)</td></tr>
<tr class="separator:a022d31e09906af1a1934a03c49f41315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da92cd3bac0a28234f3f95865afa6cb"><td class="memItemLeft" align="right" valign="top">struct sol_i2c_pending *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol-i2c_8h.html#a6da92cd3bac0a28234f3f95865afa6cb">sol_i2c_write_register</a> (struct <a class="el" href="structsol__i2c.html">sol_i2c</a> *i2c, uint8_t reg, const uint8_t *data, size_t count, void(*write_reg_cb)(void *cb_data, struct <a class="el" href="structsol__i2c.html">sol_i2c</a> *i2c, uint8_t reg, uint8_t *data, ssize_t status), const void *cb_data)</td></tr>
<tr class="separator:a6da92cd3bac0a28234f3f95865afa6cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf3bc641d763b31d2e0db61761a67c5b"><td class="memItemLeft" align="right" valign="top">struct sol_i2c_pending *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol-i2c_8h.html#abf3bc641d763b31d2e0db61761a67c5b">sol_i2c_read_register_multiple</a> (struct <a class="el" href="structsol__i2c.html">sol_i2c</a> *i2c, uint8_t reg, uint8_t *values, size_t count, uint8_t times, void(*read_reg_multiple_cb)(void *cb_data, struct <a class="el" href="structsol__i2c.html">sol_i2c</a> *i2c, uint8_t reg, uint8_t *data, ssize_t status), const void *cb_data)</td></tr>
<tr class="separator:abf3bc641d763b31d2e0db61761a67c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9810395724370f3f00acb5ab95d2969"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol-i2c_8h.html#af9810395724370f3f00acb5ab95d2969">sol_i2c_busy</a> (struct <a class="el" href="structsol__i2c.html">sol_i2c</a> *i2c)</td></tr>
<tr class="separator:af9810395724370f3f00acb5ab95d2969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af77b39c4aee929e9c75c11f6359cf458"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol-i2c_8h.html#af77b39c4aee929e9c75c11f6359cf458">sol_i2c_bus_get</a> (const struct <a class="el" href="structsol__i2c.html">sol_i2c</a> *i2c)</td></tr>
<tr class="separator:af77b39c4aee929e9c75c11f6359cf458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a598ad9006e87e32ce34d163a813efd2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol-i2c_8h.html#a598ad9006e87e32ce34d163a813efd2b">sol_i2c_pending_cancel</a> (struct <a class="el" href="structsol__i2c.html">sol_i2c</a> *i2c, struct sol_i2c_pending *<a class="el" href="structpending.html">pending</a>)</td></tr>
<tr class="separator:a598ad9006e87e32ce34d163a813efd2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>These routines are used for I2C access under Soletta. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a2a27a2238a08a352353426df1ff440d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="sol-i2c_8h.html#a2a27a2238a08a352353426df1ff440d6">sol_i2c_speed</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a2a27a2238a08a352353426df1ff440d6aae7266bcbc836ae6013609abeb7a1d3c"></a>SOL_I2C_SPEED_10KBIT</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2a27a2238a08a352353426df1ff440d6a6f3c4ddd9f4a729c90aee29a8c806752"></a>SOL_I2C_SPEED_100KBIT</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2a27a2238a08a352353426df1ff440d6aa46e872c069c9605b2eb8b9313a04b4b"></a>SOL_I2C_SPEED_400KBIT</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2a27a2238a08a352353426df1ff440d6a15f9d8ee77c27344e5d3bf8d43c474d9"></a>SOL_I2C_SPEED_1MBIT</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2a27a2238a08a352353426df1ff440d6a12945c5903700e30972b38637f8c1ff4"></a>SOL_I2C_SPEED_3MBIT_400KBIT</em>&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="af77b39c4aee929e9c75c11f6359cf458"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t sol_i2c_bus_get </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsol__i2c.html">sol_i2c</a> *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the I2C bus id</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>The I2C bus handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the bus id </dd></dl>

<p>References <a class="el" href="structsol__i2c.html#a2f8294f4fb283a223524e0e529788d2a">sol_i2c::bus</a>, <a class="el" href="structsol__i2c.html#aa16bb4f04e4d58206bd2cfffd9414e28">sol_i2c::dev</a>, and <a class="el" href="group__Log.html#gacb48844cf78438b772f069c089836835">SOL_NULL_CHECK</a>.</p>

<p>Referenced by <a class="el" href="am2315_8h.html#af0cd82fc46b398365d0585c51f657655">am2315_open()</a>, and <a class="el" href="sol-i2c-common_8c.html#a9445e3b64525a2f421bddfe762f1b5d8">sol_i2c_open()</a>.</p>

</div>
</div>
<a class="anchor" id="af9810395724370f3f00acb5ab95d2969"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sol_i2c_busy </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsol__i2c.html">sol_i2c</a> *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true if I2C bus is busy, processing another operation. This function should be called before call any other I2C function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>The I2C bus handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true is busy or false if idle </dd></dl>

<p>References <a class="el" href="structsol__i2c.html#a5f002d8c60fc3bcb8f8ed7a08ce26245">sol_i2c::async</a>, <a class="el" href="group__Log.html#gacb48844cf78438b772f069c089836835">SOL_NULL_CHECK</a>, and <a class="el" href="structsol__i2c.html#aecf57c9ca38d901a24bfaf8d1054c584">sol_i2c::timeout</a>.</p>

</div>
</div>
<a class="anchor" id="abca31deed9d3eb838a7e038aa7d4b300"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sol_i2c_close </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsol__i2c.html">sol_i2c</a> *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close an I2C bus.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>bus The I2C bus handle to close </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="structsol__i2c__shared.html#ad027ca2db7595fa0220123472b82f141">sol_i2c_shared::i2c</a>, <a class="el" href="structsol__i2c__shared.html#a48ac74ba5d9542544374037b812bc058">sol_i2c_shared::refcount</a>, <a class="el" href="sol-i2c_8h.html#abaf697f94177ca536843244fe34c3c1c">sol_i2c_close_raw()</a>, <a class="el" href="group__Log.html#gacb48844cf78438b772f069c089836835">SOL_NULL_CHECK</a>, <a class="el" href="group__Vector.html#ga0ae8dd222f4805369d43afc8e3138ca9">sol_vector_del()</a>, and <a class="el" href="group__Vector.html#gab02e3bf71600e6bd83fb26fc83935849">SOL_VECTOR_FOREACH_IDX</a>.</p>

<p>Referenced by <a class="el" href="am2315_8h.html#aed650665990453c468d62bb95928e058">am2315_close()</a>, <a class="el" href="am2315_8h.html#af0cd82fc46b398365d0585c51f657655">am2315_open()</a>, and <a class="el" href="sol-i2c-common_8c.html#a9445e3b64525a2f421bddfe762f1b5d8">sol_i2c_open()</a>.</p>

</div>
</div>
<a class="anchor" id="abaf697f94177ca536843244fe34c3c1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sol_i2c_close_raw </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsol__i2c.html">sol_i2c</a> *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close an I2C bus.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>bus The I2C bus handle to close</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This call will not remove this I2C handle from cache. Use <a class="el" href="sol-i2c_8h.html#abca31deed9d3eb838a7e038aa7d4b300">sol_i2c_close()</a> for that. </dd></dl>

<p>References <a class="el" href="structsol__i2c.html#a5f002d8c60fc3bcb8f8ed7a08ce26245">sol_i2c::async</a>, <a class="el" href="structsol__i2c.html#aa16bb4f04e4d58206bd2cfffd9414e28">sol_i2c::dev</a>, <a class="el" href="sol-i2c-impl-linux_8c.html#ac59eaa68bf76445661e8039257ecdd80">sol_i2c_pending_cancel()</a>, <a class="el" href="group__Log.html#gacb48844cf78438b772f069c089836835">SOL_NULL_CHECK</a>, and <a class="el" href="structsol__i2c.html#aecf57c9ca38d901a24bfaf8d1054c584">sol_i2c::timeout</a>.</p>

<p>Referenced by <a class="el" href="sol-i2c-common_8c.html#af66af59bd15ff59ee99f66e09ab646b6">sol_i2c_close()</a>.</p>

</div>
</div>
<a class="anchor" id="afba3760a7aa59217fd08035b07f4296b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t sol_i2c_get_slave_address </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsol__i2c.html">sol_i2c</a> *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the (slave) device address set on an I2C bus (to deliver I2C commands)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>bus The I2C bus handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The slave device address set on <em>bus</em>. <code>0x0</code> means <em>bus</em> was not set to any device yet </dd></dl>

<p>References <a class="el" href="structsol__i2c.html#a6a982930e8c567ca8fd22b25efa16085">sol_i2c::addr</a>, <a class="el" href="structsol__i2c.html#ac67be722cba1c32c9d18595e6fd61a33">sol_i2c::slave_address</a>, and <a class="el" href="group__Log.html#gacb48844cf78438b772f069c089836835">SOL_NULL_CHECK</a>.</p>

</div>
</div>
<a class="anchor" id="a43d88e4d8e1bafbcfdc36cbfe3928f5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structsol__i2c.html">sol_i2c</a>* sol_i2c_open </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="sol-i2c_8h.html#a2a27a2238a08a352353426df1ff440d6">sol_i2c_speed</a>&#160;</td>
          <td class="paramname"><em>speed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open an I2C bus.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bus</td><td>The I2C bus number to open </td></tr>
    <tr><td class="paramname">speed</td><td>The speed to open I2C bus <em>bus</em> at </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new I2C bus handle</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This call will attempt to make pin muxing operations underneath, for the given platform that the code is running in. Use <a class="el" href="sol-i2c_8h.html#a90f1c39293b17fde011fa146985f51bf">sol_i2c_open_raw()</a> if you want to skip any pin mux operation. </dd>
<dd>
The same I2C bus is shared between every user, so only the first one opening the bus will be able to set the bus speed, if some I2C slave device need to work in lower speed you need to change it on every other user of the bus. </dd></dl>

<p>References <a class="el" href="structsol__i2c__shared.html#ad027ca2db7595fa0220123472b82f141">sol_i2c_shared::i2c</a>, <a class="el" href="structsol__i2c__shared.html#a48ac74ba5d9542544374037b812bc058">sol_i2c_shared::refcount</a>, <a class="el" href="group__Log.html#ga823cf64eb1674aa6f3337e05563d5929">SOL_ERR</a>, <a class="el" href="sol-i2c_8h.html#af77b39c4aee929e9c75c11f6359cf458">sol_i2c_bus_get()</a>, <a class="el" href="sol-i2c-common_8c.html#af66af59bd15ff59ee99f66e09ab646b6">sol_i2c_close()</a>, <a class="el" href="sol-i2c_8h.html#a90f1c39293b17fde011fa146985f51bf">sol_i2c_open_raw()</a>, <a class="el" href="sol-log-internal_8h.html#a165cdb89cfc86be0c15766fdf5c9b833">SOL_LOG_INTERNAL_INIT_ONCE</a>, <a class="el" href="group__Log.html#gacb48844cf78438b772f069c089836835">SOL_NULL_CHECK</a>, <a class="el" href="group__Log.html#ga54e82836a0158b537774689043b0fb75">SOL_NULL_CHECK_GOTO</a>, <a class="el" href="sol-pin-mux_8h.html#a5ac99313a0179abdc4987e60448205f2">sol_pin_mux_setup_i2c()</a>, <a class="el" href="group__Vector.html#ga6ed33ed4bd0de3c0d4714c1fc53dd3b8">sol_vector_append()</a>, and <a class="el" href="group__Vector.html#gab02e3bf71600e6bd83fb26fc83935849">SOL_VECTOR_FOREACH_IDX</a>.</p>

<p>Referenced by <a class="el" href="am2315_8h.html#af0cd82fc46b398365d0585c51f657655">am2315_open()</a>.</p>

</div>
</div>
<a class="anchor" id="a90f1c39293b17fde011fa146985f51bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structsol__i2c.html">sol_i2c</a>* sol_i2c_open_raw </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="sol-i2c_8h.html#a2a27a2238a08a352353426df1ff440d6">sol_i2c_speed</a>&#160;</td>
          <td class="paramname"><em>speed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open an I2C bus.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bus</td><td>The I2C bus number to open </td></tr>
    <tr><td class="paramname">speed</td><td>The speed to open I2C bus <em>bus</em> at </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new I2C bus handle</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This call won't attempt to make any pin muxing operations underneath. Use <a class="el" href="sol-i2c_8h.html#a43d88e4d8e1bafbcfdc36cbfe3928f5a">sol_i2c_open()</a> for that, also this will not cache this I2C or try get an previous cached I2C handle. </dd></dl>

<p>References <a class="el" href="structsol__i2c.html#a2f8294f4fb283a223524e0e529788d2a">sol_i2c::bus</a>, <a class="el" href="structsol__i2c.html#aa16bb4f04e4d58206bd2cfffd9414e28">sol_i2c::dev</a>, <a class="el" href="structsol__i2c.html#ae6dbdb022da3cb442b2247da4b2c69c9">sol_i2c::plain_i2c</a>, <a class="el" href="sol-log-internal_8h.html#a165cdb89cfc86be0c15766fdf5c9b833">SOL_LOG_INTERNAL_INIT_ONCE</a>, <a class="el" href="group__Log.html#gacb48844cf78438b772f069c089836835">SOL_NULL_CHECK</a>, and <a class="el" href="group__Log.html#ga5d9529e9746395acc2cd96a28ffa1c28">SOL_WRN</a>.</p>

<p>Referenced by <a class="el" href="sol-i2c-common_8c.html#a9445e3b64525a2f421bddfe762f1b5d8">sol_i2c_open()</a>.</p>

</div>
</div>
<a class="anchor" id="a598ad9006e87e32ce34d163a813efd2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sol_i2c_pending_cancel </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsol__i2c.html">sol_i2c</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sol_i2c_pending *&#160;</td>
          <td class="paramname"><em>pending</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cancel a pending operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>the I2C bus handle </td></tr>
    <tr><td class="paramname">pending</td><td>the operation handle </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="structsol__i2c.html#a5f002d8c60fc3bcb8f8ed7a08ce26245">sol_i2c::async</a>, <a class="el" href="structi2c__create__device.html#a226734a7f1bcc8918e63400700e6e04e">i2c_create_device::dev_name</a>, <a class="el" href="structi2c__create__device.html#a51aac662559d7491c7fe54e68627ac76">i2c_create_device::dev_number</a>, <a class="el" href="structsol__i2c.html#a1ade2fd5a07bd28df389953cee3aae99">sol_i2c::dispatch</a>, <a class="el" href="structi2c__create__device.html#a58157b5f03f21a807db7e602c1714de7">i2c_create_device::result</a>, <a class="el" href="structi2c__create__device.html#a9f18465659a3b92ecce0bf838e40fa88">i2c_create_device::result_path</a>, <a class="el" href="group__Macros.html#ga374770937665ae002bf8d8d352c5cf99">SOL_API</a>, <a class="el" href="group__Log.html#gacb48844cf78438b772f069c089836835">SOL_NULL_CHECK</a>, <a class="el" href="group__Mainloop.html#gae1f45ba3de62603e90903d1214cf834f">sol_timeout_del()</a>, <a class="el" href="sol-util_8h.html#ab584188ab3f38605dab8b04aaa85913d">sol_util_strerrora</a>, <a class="el" href="sol-util-file_8c.html#adb0e7ccd5677385bd3d013d0627bb82d">sol_util_write_file()</a>, <a class="el" href="sol-worker-thread_8h.html#a7d60d6443f27e0c7a4a51fd4171124b6">sol_worker_thread_cancel()</a>, <a class="el" href="group__Log.html#ga5d9529e9746395acc2cd96a28ffa1c28">SOL_WRN</a>, <a class="el" href="sol-util_8h.html#ad1960bae9c7cf63547dae1a83f7883f5">strstartswith</a>, <a class="el" href="sol-i2c-impl-linux_8c.html#ac92c275da36e11c0612a611d4d15a6e4">SYSFS_I2C_NEW_DEVICE</a>, and <a class="el" href="structsol__i2c.html#aecf57c9ca38d901a24bfaf8d1054c584">sol_i2c::timeout</a>.</p>

<p>Referenced by <a class="el" href="am2315_8h.html#aed650665990453c468d62bb95928e058">am2315_close()</a>, and <a class="el" href="sol-i2c-impl-linux_8c.html#a7a6cf1ac8cadc67707f1ae88c5c02b4a">sol_i2c_close_raw()</a>.</p>

</div>
</div>
<a class="anchor" id="acfbc27121339b1e4c422fdab483d9e71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sol_i2c_pending* sol_i2c_read </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsol__i2c.html">sol_i2c</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *cb_data, struct <a class="el" href="structsol__i2c.html">sol_i2c</a> *i2c, uint8_t *data, ssize_t status)&#160;</td>
          <td class="paramname"><em>read_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>cb_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform successive asynchronous I2C byte read operations, with no specified register</p>
<p>This makes <em>count</em> read byte I2C operations on the device <em>bus</em> is set to operate on, at no specific register. Some devices are so simple that this interface is enough. For others, it is a shorthand if you want to read the same register as in the previous I2C command.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>bus The I2C bus handle </td></tr>
    <tr><td class="paramname">data</td><td>The output buffer for the read operation </td></tr>
    <tr><td class="paramname">count</td><td>The bytes count for the read operation </td></tr>
    <tr><td class="paramname">read_cb</td><td>The callback to be called when operation finish, the status parameter should be equal to count in case of success </td></tr>
    <tr><td class="paramname">cb_data</td><td>The first parameter of callback</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Caller should guarantee that data will not be freed until callback is called. Also there is no transfer queue, calling this function when there is another I2C operation running will return false.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>pending handle if operation was started otherwise a NULL pointer </dd></dl>

<p>References <a class="el" href="structsol__worker__thread__spec.html#afd3226b91658a3d3236a0d780dc6739a">sol_worker_thread_spec::api_version</a>, <a class="el" href="structsol__i2c.html#a5f002d8c60fc3bcb8f8ed7a08ce26245">sol_i2c::async</a>, <a class="el" href="sol-i2c-impl-linux_8c.html#ad20eb528a6690fc5dbccca80b6f2837f">BUSY_CHECK</a>, <a class="el" href="structsol__i2c.html#a19ba3ec4a833304592dfbab1afcbd4b1">sol_i2c::cb_data</a>, <a class="el" href="structsol__i2c.html#a55cd4ac70d54ae606293dec3405d5d05">sol_i2c::count</a>, <a class="el" href="structsol__i2c.html#aef2f664f854015f5be6456a738a766f0">sol_i2c::data</a>, <a class="el" href="structsol__i2c.html#aa16bb4f04e4d58206bd2cfffd9414e28">sol_i2c::dev</a>, <a class="el" href="structsol__i2c.html#a1ade2fd5a07bd28df389953cee3aae99">sol_i2c::dispatch</a>, <a class="el" href="structsol__i2c.html#ad25f6526d5cac0a0c1d406a819a420a4">sol_i2c::read_write_cb</a>, <a class="el" href="group__Log.html#ga7ceb60c9648222c6d1fa660ec9fc1fe6">SOL_EXP_CHECK</a>, <a class="el" href="group__Log.html#ga8b7a2ba17c9bf66ad98238f0ca591413">SOL_INT_CHECK</a>, <a class="el" href="group__Log.html#gacb48844cf78438b772f069c089836835">SOL_NULL_CHECK</a>, <a class="el" href="group__Mainloop.html#ga1e05a71a099eebeac9c2848e3661132b">sol_timeout_add()</a>, <a class="el" href="sol-worker-thread_8h.html#a647f164a728db00772ae47afc12d0653">sol_worker_thread_new()</a>, <a class="el" href="sol-worker-thread_8h.html#a13e852aa5ab554f4c230f1c5d2226b36">SOL_WORKER_THREAD_SPEC_API_VERSION</a>, <a class="el" href="structsol__i2c.html#a5670e012eb7e18ea3e7e7a61019ffcf8">sol_i2c::status</a>, and <a class="el" href="structsol__i2c.html#aecf57c9ca38d901a24bfaf8d1054c584">sol_i2c::timeout</a>.</p>

</div>
</div>
<a class="anchor" id="a022d31e09906af1a1934a03c49f41315"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sol_i2c_pending* sol_i2c_read_register </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsol__i2c.html">sol_i2c</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *cb_data, struct <a class="el" href="structsol__i2c.html">sol_i2c</a> *i2c, uint8_t reg, uint8_t *data, ssize_t status)&#160;</td>
          <td class="paramname"><em>read_reg_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>cb_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform a asynchronous I2C read operation on a given device register</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>bus The I2C bus handle </td></tr>
    <tr><td class="paramname">reg</td><td>The I2C register for the read operation </td></tr>
    <tr><td class="paramname">data</td><td>The output buffer for the read operation </td></tr>
    <tr><td class="paramname">count</td><td>The bytes count for the read operation </td></tr>
    <tr><td class="paramname">read_reg_cb</td><td>The callback to be called when operation finish, the status parameter should be equal to count in case of success </td></tr>
    <tr><td class="paramname">cb_data</td><td>The first parameter of callback</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Caller should guarantee that data will not be freed until callback is called. Also there is no transfer queue, calling this function when there is another I2C operation running will return false.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>pending handle if operation was started otherwise a NULL pointer </dd></dl>

<p>References <a class="el" href="structsol__worker__thread__spec.html#afd3226b91658a3d3236a0d780dc6739a">sol_worker_thread_spec::api_version</a>, <a class="el" href="structsol__i2c.html#a5f002d8c60fc3bcb8f8ed7a08ce26245">sol_i2c::async</a>, <a class="el" href="sol-i2c-impl-linux_8c.html#ad20eb528a6690fc5dbccca80b6f2837f">BUSY_CHECK</a>, <a class="el" href="structsol__i2c.html#a19ba3ec4a833304592dfbab1afcbd4b1">sol_i2c::cb_data</a>, <a class="el" href="structsol__i2c.html#a55cd4ac70d54ae606293dec3405d5d05">sol_i2c::count</a>, <a class="el" href="structsol__i2c.html#aef2f664f854015f5be6456a738a766f0">sol_i2c::data</a>, <a class="el" href="structsol__i2c.html#aa16bb4f04e4d58206bd2cfffd9414e28">sol_i2c::dev</a>, <a class="el" href="structsol__i2c.html#a1ade2fd5a07bd28df389953cee3aae99">sol_i2c::dispatch</a>, <a class="el" href="structsol__i2c.html#a050fc653eae0656c3269b3b85629b3b4">sol_i2c::read_write_reg_cb</a>, <a class="el" href="structsol__i2c.html#a92418402ff24cd2e1b5d56970c1a8363">sol_i2c::reg</a>, <a class="el" href="group__Log.html#ga7ceb60c9648222c6d1fa660ec9fc1fe6">SOL_EXP_CHECK</a>, <a class="el" href="group__Log.html#ga8b7a2ba17c9bf66ad98238f0ca591413">SOL_INT_CHECK</a>, <a class="el" href="group__Log.html#gacb48844cf78438b772f069c089836835">SOL_NULL_CHECK</a>, <a class="el" href="group__Mainloop.html#ga1e05a71a099eebeac9c2848e3661132b">sol_timeout_add()</a>, <a class="el" href="sol-worker-thread_8h.html#a647f164a728db00772ae47afc12d0653">sol_worker_thread_new()</a>, <a class="el" href="sol-worker-thread_8h.html#a13e852aa5ab554f4c230f1c5d2226b36">SOL_WORKER_THREAD_SPEC_API_VERSION</a>, <a class="el" href="structsol__i2c.html#a5670e012eb7e18ea3e7e7a61019ffcf8">sol_i2c::status</a>, and <a class="el" href="structsol__i2c.html#aecf57c9ca38d901a24bfaf8d1054c584">sol_i2c::timeout</a>.</p>

</div>
</div>
<a class="anchor" id="abf3bc641d763b31d2e0db61761a67c5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sol_i2c_pending* sol_i2c_read_register_multiple </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsol__i2c.html">sol_i2c</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>times</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *cb_data, struct <a class="el" href="structsol__i2c.html">sol_i2c</a> *i2c, uint8_t reg, uint8_t *data, ssize_t status)&#160;</td>
          <td class="paramname"><em>read_reg_multiple_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>cb_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Asynchronous read of an arbitrary number of bytes from a register in repeated bursts of a given length (that start always on the provided register address)</p>
<p>This is so because a lot of devices will, after a read operation, update its register values with new data to be read on subsequent operations, until the total data length the user requested is read. If the device has the auto-increment feature, <a class="el" href="sol-i2c_8h.html#a022d31e09906af1a1934a03c49f41315">sol_i2c_read_register()</a> might be a better call than this function.</p>
<p>This will issue multiple I2C read/write transactions with the first (write) message specifying the register to operate on and the second (read) message specifying the length (always <em>len</em> per read) and the destination of the read operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>bus The I2C bus handle </td></tr>
    <tr><td class="paramname">reg</td><td>The register to start reading from </td></tr>
    <tr><td class="paramname">values</td><td>Where to store the read bytes </td></tr>
    <tr><td class="paramname">count</td><td>The size of a single read block </td></tr>
    <tr><td class="paramname">times</td><td>How many reads of size <em>len</em> to perform (on success, <em>len</em> * <em>times</em> bytes will be read) </td></tr>
    <tr><td class="paramname">read_reg_multiple_cb</td><td>The callback to be called when operation finish, the status parameter should be equal to count in case of success </td></tr>
    <tr><td class="paramname">cb_data</td><td>The first parameter of callback</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Caller should guarantee that data will not be freed until callback is called. Also there is no transfer queue, calling this function when there is another I2C operation running will return false.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>pending handle if operation was started otherwise a NULL pointer </dd></dl>

<p>References <a class="el" href="structsol__worker__thread__spec.html#afd3226b91658a3d3236a0d780dc6739a">sol_worker_thread_spec::api_version</a>, <a class="el" href="structsol__i2c.html#a5f002d8c60fc3bcb8f8ed7a08ce26245">sol_i2c::async</a>, <a class="el" href="sol-i2c-impl-linux_8c.html#ad20eb528a6690fc5dbccca80b6f2837f">BUSY_CHECK</a>, <a class="el" href="structsol__i2c.html#a19ba3ec4a833304592dfbab1afcbd4b1">sol_i2c::cb_data</a>, <a class="el" href="structsol__i2c.html#a55cd4ac70d54ae606293dec3405d5d05">sol_i2c::count</a>, <a class="el" href="structsol__i2c.html#aef2f664f854015f5be6456a738a766f0">sol_i2c::data</a>, <a class="el" href="structsol__i2c.html#aa16bb4f04e4d58206bd2cfffd9414e28">sol_i2c::dev</a>, <a class="el" href="structsol__i2c.html#a1ade2fd5a07bd28df389953cee3aae99">sol_i2c::dispatch</a>, <a class="el" href="structsol__i2c.html#a050fc653eae0656c3269b3b85629b3b4">sol_i2c::read_write_reg_cb</a>, <a class="el" href="structsol__i2c.html#a92418402ff24cd2e1b5d56970c1a8363">sol_i2c::reg</a>, <a class="el" href="group__Log.html#ga7ceb60c9648222c6d1fa660ec9fc1fe6">SOL_EXP_CHECK</a>, <a class="el" href="group__Log.html#ga8b7a2ba17c9bf66ad98238f0ca591413">SOL_INT_CHECK</a>, <a class="el" href="group__Log.html#gacb48844cf78438b772f069c089836835">SOL_NULL_CHECK</a>, <a class="el" href="group__Mainloop.html#ga1e05a71a099eebeac9c2848e3661132b">sol_timeout_add()</a>, <a class="el" href="sol-worker-thread_8h.html#a647f164a728db00772ae47afc12d0653">sol_worker_thread_new()</a>, <a class="el" href="sol-worker-thread_8h.html#a13e852aa5ab554f4c230f1c5d2226b36">SOL_WORKER_THREAD_SPEC_API_VERSION</a>, <a class="el" href="structsol__i2c.html#a5670e012eb7e18ea3e7e7a61019ffcf8">sol_i2c::status</a>, <a class="el" href="structsol__i2c.html#aecf57c9ca38d901a24bfaf8d1054c584">sol_i2c::timeout</a>, and <a class="el" href="structsol__i2c.html#aecc07ad95cf26a2e9927ebe33896e976">sol_i2c::times</a>.</p>

</div>
</div>
<a class="anchor" id="ae778e276d19675d0113711629a9cb40a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sol_i2c_set_slave_address </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsol__i2c.html">sol_i2c</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>slave_address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a (slave) device address on a I2C bus to deliver commands to.</p>
<p>All other I2C functions, after this call, will act on the given <em>slave_address</em> device address. Since other I2C calls might happen in between your own ones, though, it's highly advisable that you issue this call before using any of the I2C read/write functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>bus The I2C bus handle </td></tr>
    <tr><td class="paramname">slave_address</td><td>The slave device address to deliver commands to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success, <code>false</code> otherwise. </dd></dl>

<p>References <a class="el" href="structsol__i2c.html#a6a982930e8c567ca8fd22b25efa16085">sol_i2c::addr</a>, <a class="el" href="structsol__i2c.html#a5f002d8c60fc3bcb8f8ed7a08ce26245">sol_i2c::async</a>, <a class="el" href="structsol__i2c.html#a2f8294f4fb283a223524e0e529788d2a">sol_i2c::bus</a>, <a class="el" href="sol-i2c-impl-linux_8c.html#ad20eb528a6690fc5dbccca80b6f2837f">BUSY_CHECK</a>, <a class="el" href="structsol__i2c.html#aa16bb4f04e4d58206bd2cfffd9414e28">sol_i2c::dev</a>, <a class="el" href="structsol__i2c.html#ac67be722cba1c32c9d18595e6fd61a33">sol_i2c::slave_address</a>, <a class="el" href="group__Log.html#ga7ceb60c9648222c6d1fa660ec9fc1fe6">SOL_EXP_CHECK</a>, <a class="el" href="group__Log.html#gacb48844cf78438b772f069c089836835">SOL_NULL_CHECK</a>, <a class="el" href="group__Log.html#ga5d9529e9746395acc2cd96a28ffa1c28">SOL_WRN</a>, and <a class="el" href="structsol__i2c.html#aecf57c9ca38d901a24bfaf8d1054c584">sol_i2c::timeout</a>.</p>

</div>
</div>
<a class="anchor" id="af328baecae0e32b78fe133d67273ed9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sol_i2c_pending* sol_i2c_write </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsol__i2c.html">sol_i2c</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *cb_data, struct <a class="el" href="structsol__i2c.html">sol_i2c</a> *i2c, uint8_t *data, ssize_t status)&#160;</td>
          <td class="paramname"><em>write_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>cb_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform successive asynchronous I2C byte write operations, with no specified register</p>
<p>This makes <em>count</em> write byte I2C operations on the device <em>bus</em> is set to operate on, at no specific register. Some devices are so simple that this interface is enough. For others, it is a shorthand if you want to write the same register as in the previous I2C command.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>bus The I2C bus handle </td></tr>
    <tr><td class="paramname">data</td><td>The output buffer for the write operation </td></tr>
    <tr><td class="paramname">count</td><td>The bytes count for the write operation </td></tr>
    <tr><td class="paramname">write_cb</td><td>The callback to be called when operation finish, the status parameter should be equal to count in case of success </td></tr>
    <tr><td class="paramname">cb_data</td><td>The first parameter of callback</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Caller should guarantee that data will not be freed until callback is called. Also there is no transfer queue, calling this function when there is another I2C operation running will return false.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>pending handle if operation was started otherwise a NULL pointer </dd></dl>

<p>References <a class="el" href="structsol__worker__thread__spec.html#afd3226b91658a3d3236a0d780dc6739a">sol_worker_thread_spec::api_version</a>, <a class="el" href="structsol__i2c.html#a5f002d8c60fc3bcb8f8ed7a08ce26245">sol_i2c::async</a>, <a class="el" href="sol-i2c-impl-linux_8c.html#ad20eb528a6690fc5dbccca80b6f2837f">BUSY_CHECK</a>, <a class="el" href="structsol__i2c.html#a19ba3ec4a833304592dfbab1afcbd4b1">sol_i2c::cb_data</a>, <a class="el" href="structsol__i2c.html#a55cd4ac70d54ae606293dec3405d5d05">sol_i2c::count</a>, <a class="el" href="structsol__i2c.html#aef2f664f854015f5be6456a738a766f0">sol_i2c::data</a>, <a class="el" href="structsol__i2c.html#aa16bb4f04e4d58206bd2cfffd9414e28">sol_i2c::dev</a>, <a class="el" href="structsol__i2c.html#a1ade2fd5a07bd28df389953cee3aae99">sol_i2c::dispatch</a>, <a class="el" href="structsol__i2c.html#ad25f6526d5cac0a0c1d406a819a420a4">sol_i2c::read_write_cb</a>, <a class="el" href="group__Log.html#ga7ceb60c9648222c6d1fa660ec9fc1fe6">SOL_EXP_CHECK</a>, <a class="el" href="group__Log.html#ga8b7a2ba17c9bf66ad98238f0ca591413">SOL_INT_CHECK</a>, <a class="el" href="group__Log.html#gacb48844cf78438b772f069c089836835">SOL_NULL_CHECK</a>, <a class="el" href="group__Mainloop.html#ga1e05a71a099eebeac9c2848e3661132b">sol_timeout_add()</a>, <a class="el" href="sol-worker-thread_8h.html#a647f164a728db00772ae47afc12d0653">sol_worker_thread_new()</a>, <a class="el" href="sol-worker-thread_8h.html#a13e852aa5ab554f4c230f1c5d2226b36">SOL_WORKER_THREAD_SPEC_API_VERSION</a>, <a class="el" href="structsol__i2c.html#a5670e012eb7e18ea3e7e7a61019ffcf8">sol_i2c::status</a>, and <a class="el" href="structsol__i2c.html#aecf57c9ca38d901a24bfaf8d1054c584">sol_i2c::timeout</a>.</p>

</div>
</div>
<a class="anchor" id="a07bd4788ce4eb74e1d0e395a98e5c4be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sol_i2c_pending* sol_i2c_write_quick </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsol__i2c.html">sol_i2c</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *cb_data, struct <a class="el" href="structsol__i2c.html">sol_i2c</a> *i2c, ssize_t status)&#160;</td>
          <td class="paramname"><em>write_quick_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>cb_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform a I2C write quick operation</p>
<p>This sends a single bit to a device (command designed to turn on and off simple devices)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>The I2C bus handle </td></tr>
    <tr><td class="paramname">rw</td><td>The value to write </td></tr>
    <tr><td class="paramname">write_quick_cb</td><td>The callback to be issued when the operation finishes. The status parameter should be equal to one in case of success </td></tr>
    <tr><td class="paramname">cb_data</td><td>Data to be passed to <em>write_quick_cb</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pending handle if operation was started otherwise a NULL pointer </dd></dl>

<p>References <a class="el" href="structsol__worker__thread__spec.html#afd3226b91658a3d3236a0d780dc6739a">sol_worker_thread_spec::api_version</a>, <a class="el" href="structsol__i2c.html#a5f002d8c60fc3bcb8f8ed7a08ce26245">sol_i2c::async</a>, <a class="el" href="sol-i2c-impl-linux_8c.html#ad20eb528a6690fc5dbccca80b6f2837f">BUSY_CHECK</a>, <a class="el" href="structsol__i2c.html#a19ba3ec4a833304592dfbab1afcbd4b1">sol_i2c::cb_data</a>, <a class="el" href="structsol__i2c.html#aef2f664f854015f5be6456a738a766f0">sol_i2c::data</a>, <a class="el" href="structsol__i2c.html#aa16bb4f04e4d58206bd2cfffd9414e28">sol_i2c::dev</a>, <a class="el" href="structsol__i2c.html#a1ade2fd5a07bd28df389953cee3aae99">sol_i2c::dispatch</a>, <a class="el" href="group__Log.html#ga933033cbf5e8254a85531e110d1a04cc">SOL_CRI</a>, <a class="el" href="group__Log.html#ga8b7a2ba17c9bf66ad98238f0ca591413">SOL_INT_CHECK</a>, <a class="el" href="group__Log.html#gacb48844cf78438b772f069c089836835">SOL_NULL_CHECK</a>, <a class="el" href="group__Mainloop.html#ga1e05a71a099eebeac9c2848e3661132b">sol_timeout_add()</a>, <a class="el" href="sol-worker-thread_8h.html#a647f164a728db00772ae47afc12d0653">sol_worker_thread_new()</a>, <a class="el" href="sol-worker-thread_8h.html#a13e852aa5ab554f4c230f1c5d2226b36">SOL_WORKER_THREAD_SPEC_API_VERSION</a>, <a class="el" href="structsol__i2c.html#a5670e012eb7e18ea3e7e7a61019ffcf8">sol_i2c::status</a>, <a class="el" href="structsol__i2c.html#aecf57c9ca38d901a24bfaf8d1054c584">sol_i2c::timeout</a>, and <a class="el" href="structsol__i2c.html#a3bc1f2d0e18af3cf26f5f514d71e09b7">sol_i2c::write_quick_cb</a>.</p>

</div>
</div>
<a class="anchor" id="a6da92cd3bac0a28234f3f95865afa6cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sol_i2c_pending* sol_i2c_write_register </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsol__i2c.html">sol_i2c</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *cb_data, struct <a class="el" href="structsol__i2c.html">sol_i2c</a> *i2c, uint8_t reg, uint8_t *data, ssize_t status)&#160;</td>
          <td class="paramname"><em>write_reg_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>cb_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform a asynchronous I2C write operation on a given device register</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>bus The I2C bus handle </td></tr>
    <tr><td class="paramname">reg</td><td>The I2C register for the write operation </td></tr>
    <tr><td class="paramname">data</td><td>The output buffer for the write operation </td></tr>
    <tr><td class="paramname">count</td><td>The bytes count for the write operation </td></tr>
    <tr><td class="paramname">write_reg_cb</td><td>The callback to be called when operation finish, the status parameter should be equal to count in case of success </td></tr>
    <tr><td class="paramname">cb_data</td><td>The first parameter of callback</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Caller should guarantee that data will not be freed until callback is called. Also there is no transfer queue, calling this function when there is another I2C operation running will return false.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>pending handle if operation was started otherwise a NULL pointer </dd></dl>

<p>References <a class="el" href="structsol__worker__thread__spec.html#afd3226b91658a3d3236a0d780dc6739a">sol_worker_thread_spec::api_version</a>, <a class="el" href="structsol__i2c.html#a5f002d8c60fc3bcb8f8ed7a08ce26245">sol_i2c::async</a>, <a class="el" href="sol-i2c-impl-linux_8c.html#ad20eb528a6690fc5dbccca80b6f2837f">BUSY_CHECK</a>, <a class="el" href="structsol__i2c.html#a19ba3ec4a833304592dfbab1afcbd4b1">sol_i2c::cb_data</a>, <a class="el" href="structsol__i2c.html#a55cd4ac70d54ae606293dec3405d5d05">sol_i2c::count</a>, <a class="el" href="structsol__i2c.html#aef2f664f854015f5be6456a738a766f0">sol_i2c::data</a>, <a class="el" href="structsol__i2c.html#aa16bb4f04e4d58206bd2cfffd9414e28">sol_i2c::dev</a>, <a class="el" href="structsol__i2c.html#a1ade2fd5a07bd28df389953cee3aae99">sol_i2c::dispatch</a>, <a class="el" href="structsol__i2c.html#a050fc653eae0656c3269b3b85629b3b4">sol_i2c::read_write_reg_cb</a>, <a class="el" href="structsol__i2c.html#a92418402ff24cd2e1b5d56970c1a8363">sol_i2c::reg</a>, <a class="el" href="group__Log.html#ga7ceb60c9648222c6d1fa660ec9fc1fe6">SOL_EXP_CHECK</a>, <a class="el" href="group__Log.html#ga8b7a2ba17c9bf66ad98238f0ca591413">SOL_INT_CHECK</a>, <a class="el" href="group__Log.html#gacb48844cf78438b772f069c089836835">SOL_NULL_CHECK</a>, <a class="el" href="group__Mainloop.html#ga1e05a71a099eebeac9c2848e3661132b">sol_timeout_add()</a>, <a class="el" href="sol-worker-thread_8h.html#a647f164a728db00772ae47afc12d0653">sol_worker_thread_new()</a>, <a class="el" href="sol-worker-thread_8h.html#a13e852aa5ab554f4c230f1c5d2226b36">SOL_WORKER_THREAD_SPEC_API_VERSION</a>, <a class="el" href="structsol__i2c.html#a5670e012eb7e18ea3e7e7a61019ffcf8">sol_i2c::status</a>, and <a class="el" href="structsol__i2c.html#aecf57c9ca38d901a24bfaf8d1054c584">sol_i2c::timeout</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
