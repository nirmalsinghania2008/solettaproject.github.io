<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Soletta: I2C</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Soletta
   </div>
   <div id="projectbrief">Framework for making IoT devices</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">I2C<div class="ingroups"><a class="el" href="group__IO.html">I/O</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>IÂ²C (Inter-Integrated Circuit) API for Soletta.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga2a27a2238a08a352353426df1ff440d6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga2a27a2238a08a352353426df1ff440d6">sol_i2c_speed</a> { <br/>
&#160;&#160;<a class="el" href="group__I2C.html#gga2a27a2238a08a352353426df1ff440d6aae7266bcbc836ae6013609abeb7a1d3c">SOL_I2C_SPEED_10KBIT</a> = 0, 
<a class="el" href="group__I2C.html#gga2a27a2238a08a352353426df1ff440d6a6f3c4ddd9f4a729c90aee29a8c806752">SOL_I2C_SPEED_100KBIT</a>, 
<a class="el" href="group__I2C.html#gga2a27a2238a08a352353426df1ff440d6aa46e872c069c9605b2eb8b9313a04b4b">SOL_I2C_SPEED_400KBIT</a>, 
<a class="el" href="group__I2C.html#gga2a27a2238a08a352353426df1ff440d6a15f9d8ee77c27344e5d3bf8d43c474d9">SOL_I2C_SPEED_1MBIT</a>, 
<br/>
&#160;&#160;<a class="el" href="group__I2C.html#gga2a27a2238a08a352353426df1ff440d6a12945c5903700e30972b38637f8c1ff4">SOL_I2C_SPEED_3MBIT_400KBIT</a>
<br/>
 }</td></tr>
<tr class="memdesc:ga2a27a2238a08a352353426df1ff440d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C pending operation handle structure.  <a href="group__I2C.html#ga2a27a2238a08a352353426df1ff440d6">More...</a><br/></td></tr>
<tr class="separator:ga2a27a2238a08a352353426df1ff440d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf77b39c4aee929e9c75c11f6359cf458"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gaf77b39c4aee929e9c75c11f6359cf458">sol_i2c_bus_get</a> (const struct sol_i2c *i2c)</td></tr>
<tr class="memdesc:gaf77b39c4aee929e9c75c11f6359cf458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the I2C bus ID.  <a href="#gaf77b39c4aee929e9c75c11f6359cf458">More...</a><br/></td></tr>
<tr class="separator:gaf77b39c4aee929e9c75c11f6359cf458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9810395724370f3f00acb5ab95d2969"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gaf9810395724370f3f00acb5ab95d2969">sol_i2c_busy</a> (struct sol_i2c *i2c)</td></tr>
<tr class="memdesc:gaf9810395724370f3f00acb5ab95d2969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if I2C handle's bus is busy, processing another operation.  <a href="#gaf9810395724370f3f00acb5ab95d2969">More...</a><br/></td></tr>
<tr class="separator:gaf9810395724370f3f00acb5ab95d2969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabca31deed9d3eb838a7e038aa7d4b300"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gabca31deed9d3eb838a7e038aa7d4b300">sol_i2c_close</a> (struct sol_i2c *i2c)</td></tr>
<tr class="memdesc:gabca31deed9d3eb838a7e038aa7d4b300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close an I2C bus.  <a href="#gabca31deed9d3eb838a7e038aa7d4b300">More...</a><br/></td></tr>
<tr class="separator:gabca31deed9d3eb838a7e038aa7d4b300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabaf697f94177ca536843244fe34c3c1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gabaf697f94177ca536843244fe34c3c1c">sol_i2c_close_raw</a> (struct sol_i2c *i2c)</td></tr>
<tr class="memdesc:gabaf697f94177ca536843244fe34c3c1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close an I2C bus.  <a href="#gabaf697f94177ca536843244fe34c3c1c">More...</a><br/></td></tr>
<tr class="separator:gabaf697f94177ca536843244fe34c3c1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafba3760a7aa59217fd08035b07f4296b"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gafba3760a7aa59217fd08035b07f4296b">sol_i2c_get_slave_address</a> (struct sol_i2c *i2c)</td></tr>
<tr class="memdesc:gafba3760a7aa59217fd08035b07f4296b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the (slave) device address set on an I2C bus (to deliver I2C commands to)  <a href="#gafba3760a7aa59217fd08035b07f4296b">More...</a><br/></td></tr>
<tr class="separator:gafba3760a7aa59217fd08035b07f4296b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43d88e4d8e1bafbcfdc36cbfe3928f5a"><td class="memItemLeft" align="right" valign="top">struct sol_i2c *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga43d88e4d8e1bafbcfdc36cbfe3928f5a">sol_i2c_open</a> (uint8_t bus, enum <a class="el" href="group__I2C.html#ga2a27a2238a08a352353426df1ff440d6">sol_i2c_speed</a> speed) <a class="el" href="group__Macros.html#ga57f3ea0b29f2eb5c047347b788e34db0">SOL_ATTR_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:ga43d88e4d8e1bafbcfdc36cbfe3928f5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open an I2C bus.  <a href="#ga43d88e4d8e1bafbcfdc36cbfe3928f5a">More...</a><br/></td></tr>
<tr class="separator:ga43d88e4d8e1bafbcfdc36cbfe3928f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90f1c39293b17fde011fa146985f51bf"><td class="memItemLeft" align="right" valign="top">struct sol_i2c *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga90f1c39293b17fde011fa146985f51bf">sol_i2c_open_raw</a> (uint8_t bus, enum <a class="el" href="group__I2C.html#ga2a27a2238a08a352353426df1ff440d6">sol_i2c_speed</a> speed) <a class="el" href="group__Macros.html#ga57f3ea0b29f2eb5c047347b788e34db0">SOL_ATTR_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:ga90f1c39293b17fde011fa146985f51bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open an I2C bus.  <a href="#ga90f1c39293b17fde011fa146985f51bf">More...</a><br/></td></tr>
<tr class="separator:ga90f1c39293b17fde011fa146985f51bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga598ad9006e87e32ce34d163a813efd2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga598ad9006e87e32ce34d163a813efd2b">sol_i2c_pending_cancel</a> (struct sol_i2c *i2c, struct sol_i2c_pending *<a class="el" href="download_8c.html#add7d3a20f2cd7ffcb80b6c9a3cb4b8f9">pending</a>)</td></tr>
<tr class="memdesc:ga598ad9006e87e32ce34d163a813efd2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel a pending operation.  <a href="#ga598ad9006e87e32ce34d163a813efd2b">More...</a><br/></td></tr>
<tr class="separator:ga598ad9006e87e32ce34d163a813efd2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfbc27121339b1e4c422fdab483d9e71"><td class="memItemLeft" align="right" valign="top">struct sol_i2c_pending *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gacfbc27121339b1e4c422fdab483d9e71">sol_i2c_read</a> (struct sol_i2c *i2c, uint8_t *data, size_t count, void(*read_cb)(void *cb_data, struct sol_i2c *i2c, uint8_t *data, ssize_t status), const void *cb_data)</td></tr>
<tr class="memdesc:gacfbc27121339b1e4c422fdab483d9e71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform successive asynchronous I2C byte read operations, with no specified register.  <a href="#gacfbc27121339b1e4c422fdab483d9e71">More...</a><br/></td></tr>
<tr class="separator:gacfbc27121339b1e4c422fdab483d9e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga022d31e09906af1a1934a03c49f41315"><td class="memItemLeft" align="right" valign="top">struct sol_i2c_pending *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga022d31e09906af1a1934a03c49f41315">sol_i2c_read_register</a> (struct sol_i2c *i2c, uint8_t reg, uint8_t *data, size_t count, void(*read_reg_cb)(void *cb_data, struct sol_i2c *i2c, uint8_t reg, uint8_t *data, ssize_t status), const void *cb_data)</td></tr>
<tr class="memdesc:ga022d31e09906af1a1934a03c49f41315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an asynchronous I2C read operation on a given device register.  <a href="#ga022d31e09906af1a1934a03c49f41315">More...</a><br/></td></tr>
<tr class="separator:ga022d31e09906af1a1934a03c49f41315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf3bc641d763b31d2e0db61761a67c5b"><td class="memItemLeft" align="right" valign="top">struct sol_i2c_pending *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gabf3bc641d763b31d2e0db61761a67c5b">sol_i2c_read_register_multiple</a> (struct sol_i2c *i2c, uint8_t reg, uint8_t *values, size_t count, uint8_t times, void(*read_reg_multiple_cb)(void *cb_data, struct sol_i2c *i2c, uint8_t reg, uint8_t *data, ssize_t status), const void *cb_data)</td></tr>
<tr class="memdesc:gabf3bc641d763b31d2e0db61761a67c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous read of an arbitrary number of bytes from a register in repeated bursts of a given length (that start always on the provided register address)  <a href="#gabf3bc641d763b31d2e0db61761a67c5b">More...</a><br/></td></tr>
<tr class="separator:gabf3bc641d763b31d2e0db61761a67c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae778e276d19675d0113711629a9cb40a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gae778e276d19675d0113711629a9cb40a">sol_i2c_set_slave_address</a> (struct sol_i2c *i2c, uint8_t slave_address)</td></tr>
<tr class="memdesc:gae778e276d19675d0113711629a9cb40a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a (slave) device address on a I2C bus to deliver commands to.  <a href="#gae778e276d19675d0113711629a9cb40a">More...</a><br/></td></tr>
<tr class="separator:gae778e276d19675d0113711629a9cb40a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf328baecae0e32b78fe133d67273ed9a"><td class="memItemLeft" align="right" valign="top">struct sol_i2c_pending *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gaf328baecae0e32b78fe133d67273ed9a">sol_i2c_write</a> (struct sol_i2c *i2c, uint8_t *data, size_t count, void(*write_cb)(void *cb_data, struct sol_i2c *i2c, uint8_t *data, ssize_t status), const void *cb_data)</td></tr>
<tr class="memdesc:gaf328baecae0e32b78fe133d67273ed9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform successive asynchronous I2C byte write operations, with no specified register.  <a href="#gaf328baecae0e32b78fe133d67273ed9a">More...</a><br/></td></tr>
<tr class="separator:gaf328baecae0e32b78fe133d67273ed9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07bd4788ce4eb74e1d0e395a98e5c4be"><td class="memItemLeft" align="right" valign="top">struct sol_i2c_pending *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga07bd4788ce4eb74e1d0e395a98e5c4be">sol_i2c_write_quick</a> (struct sol_i2c *i2c, bool rw, void(*write_quick_cb)(void *cb_data, struct sol_i2c *i2c, ssize_t status), const void *cb_data)</td></tr>
<tr class="memdesc:ga07bd4788ce4eb74e1d0e395a98e5c4be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a I2C write quick operation.  <a href="#ga07bd4788ce4eb74e1d0e395a98e5c4be">More...</a><br/></td></tr>
<tr class="separator:ga07bd4788ce4eb74e1d0e395a98e5c4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6da92cd3bac0a28234f3f95865afa6cb"><td class="memItemLeft" align="right" valign="top">struct sol_i2c_pending *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga6da92cd3bac0a28234f3f95865afa6cb">sol_i2c_write_register</a> (struct sol_i2c *i2c, uint8_t reg, const uint8_t *data, size_t count, void(*write_reg_cb)(void *cb_data, struct sol_i2c *i2c, uint8_t reg, uint8_t *data, ssize_t status), const void *cb_data)</td></tr>
<tr class="memdesc:ga6da92cd3bac0a28234f3f95865afa6cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an asynchronous I2C write operation on a given device register.  <a href="#ga6da92cd3bac0a28234f3f95865afa6cb">More...</a><br/></td></tr>
<tr class="separator:ga6da92cd3bac0a28234f3f95865afa6cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>IÂ²C (Inter-Integrated Circuit) API for Soletta. </p>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga2a27a2238a08a352353426df1ff440d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__I2C.html#ga2a27a2238a08a352353426df1ff440d6">sol_i2c_speed</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C pending operation handle structure. </p>
<p>Enum for I2C bus speed.</p>
<p>Must be choosen when opening a bus with <a class="el" href="group__I2C.html#ga43d88e4d8e1bafbcfdc36cbfe3928f5a" title="Open an I2C bus. ">sol_i2c_open()</a> and <a class="el" href="group__I2C.html#ga90f1c39293b17fde011fa146985f51bf" title="Open an I2C bus. ">sol_i2c_open_raw()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gga2a27a2238a08a352353426df1ff440d6aae7266bcbc836ae6013609abeb7a1d3c"></a>SOL_I2C_SPEED_10KBIT</em>&#160;</td><td class="fielddoc">
<p>flag for low speed </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga2a27a2238a08a352353426df1ff440d6a6f3c4ddd9f4a729c90aee29a8c806752"></a>SOL_I2C_SPEED_100KBIT</em>&#160;</td><td class="fielddoc">
<p>flag for normal speed </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga2a27a2238a08a352353426df1ff440d6aa46e872c069c9605b2eb8b9313a04b4b"></a>SOL_I2C_SPEED_400KBIT</em>&#160;</td><td class="fielddoc">
<p>flag for fast speed </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga2a27a2238a08a352353426df1ff440d6a15f9d8ee77c27344e5d3bf8d43c474d9"></a>SOL_I2C_SPEED_1MBIT</em>&#160;</td><td class="fielddoc">
<p>flag for fast plus speed </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga2a27a2238a08a352353426df1ff440d6a12945c5903700e30972b38637f8c1ff4"></a>SOL_I2C_SPEED_3MBIT_400KBIT</em>&#160;</td><td class="fielddoc">
<p>flag for high speed </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaf77b39c4aee929e9c75c11f6359cf458"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t sol_i2c_bus_get </td>
          <td>(</td>
          <td class="paramtype">const struct sol_i2c *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the I2C bus ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>The I2C bus handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the bus id </dd></dl>

</div>
</div>
<a class="anchor" id="gaf9810395724370f3f00acb5ab95d2969"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sol_i2c_busy </td>
          <td>(</td>
          <td class="paramtype">struct sol_i2c *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if I2C handle's bus is busy, processing another operation. </p>
<p>This function should be called before issuing any other I2C function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>The I2C bus handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true is busy or false if idle </dd></dl>

</div>
</div>
<a class="anchor" id="gabca31deed9d3eb838a7e038aa7d4b300"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sol_i2c_close </td>
          <td>(</td>
          <td class="paramtype">struct sol_i2c *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close an I2C bus. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>The I2C bus handle to close </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabaf697f94177ca536843244fe34c3c1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sol_i2c_close_raw </td>
          <td>(</td>
          <td class="paramtype">struct sol_i2c *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close an I2C bus. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>The I2C bus handle to close</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This call will not remove this I2C handle from cache. Use <a class="el" href="group__I2C.html#gabca31deed9d3eb838a7e038aa7d4b300" title="Close an I2C bus. ">sol_i2c_close()</a> for that. </dd></dl>

</div>
</div>
<a class="anchor" id="gafba3760a7aa59217fd08035b07f4296b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t sol_i2c_get_slave_address </td>
          <td>(</td>
          <td class="paramtype">struct sol_i2c *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the (slave) device address set on an I2C bus (to deliver I2C commands to) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>The I2C bus handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The slave device address set on <em>bus</em>. <code>0x0</code> means <em>bus</em> was not set to any device yet </dd></dl>

</div>
</div>
<a class="anchor" id="ga43d88e4d8e1bafbcfdc36cbfe3928f5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sol_i2c* sol_i2c_open </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__I2C.html#ga2a27a2238a08a352353426df1ff440d6">sol_i2c_speed</a>&#160;</td>
          <td class="paramname"><em>speed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open an I2C bus. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bus</td><td>The I2C bus number to open </td></tr>
    <tr><td class="paramname">speed</td><td>The speed to open I2C bus <em>bus</em> at </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new I2C bus handle</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This call will attempt to make pin muxing operations underneath, for the given platform that the code is running in. Use <a class="el" href="group__I2C.html#ga90f1c39293b17fde011fa146985f51bf" title="Open an I2C bus. ">sol_i2c_open_raw()</a> if you want to skip any pin mux operation.</dd>
<dd>
The same I2C bus is shared between every user, so only the first one opening a bus will be able to set its speed. If some I2C slave device needs to work in bus speed different than the current one, then you need close the current I2C handle and get another one at in the desired speed, affecting all other users/devices. </dd></dl>

</div>
</div>
<a class="anchor" id="ga90f1c39293b17fde011fa146985f51bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sol_i2c* sol_i2c_open_raw </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__I2C.html#ga2a27a2238a08a352353426df1ff440d6">sol_i2c_speed</a>&#160;</td>
          <td class="paramname"><em>speed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open an I2C bus. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bus</td><td>The I2C bus number to open </td></tr>
    <tr><td class="paramname">speed</td><td>The speed to open I2C bus <em>bus</em> at </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new I2C bus handle</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This call won't attempt to make any pin muxing operations underneath. Use <a class="el" href="group__I2C.html#ga43d88e4d8e1bafbcfdc36cbfe3928f5a" title="Open an I2C bus. ">sol_i2c_open()</a> for that. Also, this will never cache this I2C handle (or return any previously cached I2C handle). </dd></dl>

</div>
</div>
<a class="anchor" id="ga598ad9006e87e32ce34d163a813efd2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sol_i2c_pending_cancel </td>
          <td>(</td>
          <td class="paramtype">struct sol_i2c *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sol_i2c_pending *&#160;</td>
          <td class="paramname"><em>pending</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancel a pending operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>the I2C bus handle </td></tr>
    <tr><td class="paramname">pending</td><td>the operation handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacfbc27121339b1e4c422fdab483d9e71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sol_i2c_pending* sol_i2c_read </td>
          <td>(</td>
          <td class="paramtype">struct sol_i2c *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *cb_data, struct sol_i2c *i2c, uint8_t *data, ssize_t status)&#160;</td>
          <td class="paramname"><em>read_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>cb_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform successive asynchronous I2C byte read operations, with no specified register. </p>
<p>This makes <em>count</em> read byte I2C operations on the device <em>bus</em> is set to operate on, at no specific register. Some devices are so simple that this interface is enough. For others, it is a shorthand if you want to read the same register as in the previous I2C command.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>The I2C bus handle </td></tr>
    <tr><td class="paramname">data</td><td>The output buffer for the read operation </td></tr>
    <tr><td class="paramname">count</td><td>The bytes count for the read operation </td></tr>
    <tr><td class="paramname">read_cb</td><td>The callback to be called when operation finish, the status parameter should be equal to count in case of success (or a negative error code, on failure) </td></tr>
    <tr><td class="paramname">cb_data</td><td>The first parameter of callback</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The caller should guarantee that data will not be freed until the callback is called. Also there is no transfer queue, calling this function when there is another I2C operation running will return false.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>pending An I2C pending operation handle on success, otherwise <code>NULL</code>. It's only valid before <em>read_cb</em> is called. It may be used before that to cancel the read operation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga022d31e09906af1a1934a03c49f41315"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sol_i2c_pending* sol_i2c_read_register </td>
          <td>(</td>
          <td class="paramtype">struct sol_i2c *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *cb_data, struct sol_i2c *i2c, uint8_t reg, uint8_t *data, ssize_t status)&#160;</td>
          <td class="paramname"><em>read_reg_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>cb_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform an asynchronous I2C read operation on a given device register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>The I2C bus handle </td></tr>
    <tr><td class="paramname">reg</td><td>The I2C register for the read operation </td></tr>
    <tr><td class="paramname">data</td><td>The output buffer for the read operation </td></tr>
    <tr><td class="paramname">count</td><td>The bytes count for the read operation </td></tr>
    <tr><td class="paramname">read_reg_cb</td><td>The callback to be called when operation finish, the status parameter should be equal to count in case of success (or a negative error code, on failure) </td></tr>
    <tr><td class="paramname">cb_data</td><td>The first parameter of callback</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The caller should guarantee that data will not be freed until the callback is called. Also there is no transfer queue, calling this function when there is another I2C operation running will return false.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>pending An I2C pending operation handle on success, otherwise <code>NULL</code>. It's only valid before <em>read_reg_cb</em> is called. It may be used before that to cancel the read operation. </dd></dl>

</div>
</div>
<a class="anchor" id="gabf3bc641d763b31d2e0db61761a67c5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sol_i2c_pending* sol_i2c_read_register_multiple </td>
          <td>(</td>
          <td class="paramtype">struct sol_i2c *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>times</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *cb_data, struct sol_i2c *i2c, uint8_t reg, uint8_t *data, ssize_t status)&#160;</td>
          <td class="paramname"><em>read_reg_multiple_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>cb_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous read of an arbitrary number of bytes from a register in repeated bursts of a given length (that start always on the provided register address) </p>
<p>This is so because a lot of devices will, after a read operation, update its register values with new data to be read on subsequent operations, until the total data length the user requested is read. If the device has the auto-increment feature, <a class="el" href="group__I2C.html#ga022d31e09906af1a1934a03c49f41315" title="Perform an asynchronous I2C read operation on a given device register. ">sol_i2c_read_register()</a> might be a better call than this function.</p>
<p>This will issue multiple I2C read/write transactions with the first (write) message specifying the register to operate on and the second (read) message specifying the length (always <em>len</em> per read) and the destination of the read operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>The I2C bus handle </td></tr>
    <tr><td class="paramname">reg</td><td>The register to start reading from </td></tr>
    <tr><td class="paramname">values</td><td>Where to store the read bytes </td></tr>
    <tr><td class="paramname">count</td><td>The size of a single read block </td></tr>
    <tr><td class="paramname">times</td><td>How many reads of size <em>len</em> to perform (on success, <em>len</em> * <em>times</em> bytes will be read) </td></tr>
    <tr><td class="paramname">read_reg_multiple_cb</td><td>The callback to be called when the operation finishes. The status parameter should be equal to count in case of success (or a negative error code, on failure) </td></tr>
    <tr><td class="paramname">cb_data</td><td>The first parameter of callback</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The caller should guarantee that data will not be freed until the callback is called. Also there is no transfer queue, calling this function when there is another I2C operation running will return false.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>pending An I2C pending operation handle on success, otherwise <code>NULL</code>. It's only valid before <em>read_reg_multiple_cb</em> is called. It may be used before that to cancel the read operation. </dd></dl>

</div>
</div>
<a class="anchor" id="gae778e276d19675d0113711629a9cb40a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sol_i2c_set_slave_address </td>
          <td>(</td>
          <td class="paramtype">struct sol_i2c *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>slave_address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a (slave) device address on a I2C bus to deliver commands to. </p>
<p>All other I2C functions, after this call, will act on the given <em>slave_address</em> device address. Since other I2C calls might happen in between your own ones, though, it's highly advisable that you issue this call before using any of the I2C read/write functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>The I2C bus handle </td></tr>
    <tr><td class="paramname">slave_address</td><td>The slave device address to deliver commands to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf328baecae0e32b78fe133d67273ed9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sol_i2c_pending* sol_i2c_write </td>
          <td>(</td>
          <td class="paramtype">struct sol_i2c *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *cb_data, struct sol_i2c *i2c, uint8_t *data, ssize_t status)&#160;</td>
          <td class="paramname"><em>write_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>cb_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform successive asynchronous I2C byte write operations, with no specified register. </p>
<p>This makes <em>count</em> write byte I2C operations on the device <em>bus</em> is set to operate on, at no specific register. Some devices are so simple that this interface is enough. For others, it is a shorthand if you want to write the same register as in the previous I2C command.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>The I2C bus handle </td></tr>
    <tr><td class="paramname">data</td><td>The output buffer for the write operation </td></tr>
    <tr><td class="paramname">count</td><td>The bytes count for the write operation </td></tr>
    <tr><td class="paramname">write_cb</td><td>The callback to be called when operation finish, the status parameter should be equal to count in case of success (or a negative error code, on failure) </td></tr>
    <tr><td class="paramname">cb_data</td><td>The first parameter of callback</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The caller should guarantee that data will not be freed until the callback is called. Also there is no transfer queue, calling this function when there is another I2C operation running will return false.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>pending An I2C pending operation handle on success, otherwise <code>NULL</code>. It's only valid before <em>write_cb</em> is called. It may be used before that to cancel the read operation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga07bd4788ce4eb74e1d0e395a98e5c4be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sol_i2c_pending* sol_i2c_write_quick </td>
          <td>(</td>
          <td class="paramtype">struct sol_i2c *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *cb_data, struct sol_i2c *i2c, ssize_t status)&#160;</td>
          <td class="paramname"><em>write_quick_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>cb_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a I2C write quick operation. </p>
<p>This sends a single bit to a device (command designed to turn on and off simple devices)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>The I2C bus handle </td></tr>
    <tr><td class="paramname">rw</td><td>The value to write </td></tr>
    <tr><td class="paramname">write_quick_cb</td><td>The callback to be issued when the operation finishes. The status parameter should be equal to one in case of success (or a negative error code, on failure) </td></tr>
    <tr><td class="paramname">cb_data</td><td>Data to be passed to <em>write_quick_cb</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pending An I2C pending operation handle on success, otherwise <code>NULL</code>. It's only valid before <em>write_quick_cb</em> is called. It may be used before that to cancel the read operation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6da92cd3bac0a28234f3f95865afa6cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sol_i2c_pending* sol_i2c_write_register </td>
          <td>(</td>
          <td class="paramtype">struct sol_i2c *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *cb_data, struct sol_i2c *i2c, uint8_t reg, uint8_t *data, ssize_t status)&#160;</td>
          <td class="paramname"><em>write_reg_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>cb_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform an asynchronous I2C write operation on a given device register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>The I2C bus handle </td></tr>
    <tr><td class="paramname">reg</td><td>The I2C register for the write operation </td></tr>
    <tr><td class="paramname">data</td><td>The output buffer for the write operation </td></tr>
    <tr><td class="paramname">count</td><td>The bytes count for the write operation </td></tr>
    <tr><td class="paramname">write_reg_cb</td><td>The callback to be called when operation finish, the status parameter should be equal to count in case of success (or a negative error code, on failure) </td></tr>
    <tr><td class="paramname">cb_data</td><td>The first parameter of callback</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The caller should guarantee that data will not be freed until the callback is called. Also there is no transfer queue, calling this function when there is another I2C operation running will return false.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>pending An I2C pending operation handle on success, otherwise <code>NULL</code>. It's only valid before <em>write_reg_cb</em> is called. It may be used before that to cancel the read operation. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
