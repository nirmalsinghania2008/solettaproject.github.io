<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Soletta: Soletta utility functions.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Soletta
   </div>
   <div id="projectbrief">Framework for making IoT devices</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Soletta utility functions.</div>  </div>
</div><!--header-->
<div class="contents">

<p>Contains helpers to manipulate time, error code/string, overflows, encode/decode data and some converters.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__File-utils"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__File-utils.html">Soletta file utility functions</a></td></tr>
<tr class="memdesc:group__File-utils"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains helpers to deal with files. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gad443945ba007cd32410dcee65fa3c8f8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#gad443945ba007cd32410dcee65fa3c8f8">SOL_MSEC_PER_SEC</a>&#160;&#160;&#160;1000ULL</td></tr>
<tr class="memdesc:gad443945ba007cd32410dcee65fa3c8f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of milliseconds in a second: 1,000.  <a href="#gad443945ba007cd32410dcee65fa3c8f8">More...</a><br/></td></tr>
<tr class="separator:gad443945ba007cd32410dcee65fa3c8f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc59dcf2bc73c7064daf59a26fa65114"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#gafc59dcf2bc73c7064daf59a26fa65114">SOL_NSEC_PER_MSEC</a>&#160;&#160;&#160;1000000ULL</td></tr>
<tr class="memdesc:gafc59dcf2bc73c7064daf59a26fa65114"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of nanoseconds in a milliseconds: 1,000,000,000 / 1,000 = 1,000,000.  <a href="#gafc59dcf2bc73c7064daf59a26fa65114">More...</a><br/></td></tr>
<tr class="separator:gafc59dcf2bc73c7064daf59a26fa65114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fb4b46fdbc848b218900018782af213"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga1fb4b46fdbc848b218900018782af213">SOL_NSEC_PER_SEC</a>&#160;&#160;&#160;1000000000ULL</td></tr>
<tr class="memdesc:ga1fb4b46fdbc848b218900018782af213"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of nanoseconds in a second: 1,000,000,000.  <a href="#ga1fb4b46fdbc848b218900018782af213">More...</a><br/></td></tr>
<tr class="separator:ga1fb4b46fdbc848b218900018782af213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79e9522def5d06e917947f0d223aefce"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga79e9522def5d06e917947f0d223aefce">SOL_NSEC_PER_USEC</a>&#160;&#160;&#160;1000ULL</td></tr>
<tr class="memdesc:ga79e9522def5d06e917947f0d223aefce"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of nanoseconds in a microsecond: 1,000,000,000 / 1,000,000 = 1,000.  <a href="#ga79e9522def5d06e917947f0d223aefce">More...</a><br/></td></tr>
<tr class="separator:ga79e9522def5d06e917947f0d223aefce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75edadeb46b279bfcfdab26ca9fd62b1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga75edadeb46b279bfcfdab26ca9fd62b1">sol_uint16_bytes_swap</a>(val)&#160;&#160;&#160;((uint16_t)((((val) &gt;&gt; 8) &amp; 0xff) | (((val) &amp; 0xff) &lt;&lt; 8)))</td></tr>
<tr class="memdesc:ga75edadeb46b279bfcfdab26ca9fd62b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the bytes of a 16 bytes unsigned int.  <a href="#ga75edadeb46b279bfcfdab26ca9fd62b1">More...</a><br/></td></tr>
<tr class="separator:ga75edadeb46b279bfcfdab26ca9fd62b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7a585389facb08e97c35c1de254978c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#gae7a585389facb08e97c35c1de254978c">sol_uint32_bytes_swap</a>(val)</td></tr>
<tr class="memdesc:gae7a585389facb08e97c35c1de254978c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the bytes of a 32 bytes unsigned int.  <a href="#gae7a585389facb08e97c35c1de254978c">More...</a><br/></td></tr>
<tr class="separator:gae7a585389facb08e97c35c1de254978c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68b69dc86a88439f2880fa7eab00e6a8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga68b69dc86a88439f2880fa7eab00e6a8">sol_uint64_bytes_swap</a>(val)</td></tr>
<tr class="memdesc:ga68b69dc86a88439f2880fa7eab00e6a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the bytes of a 32 bytes unsigned int.  <a href="#ga68b69dc86a88439f2880fa7eab00e6a8">More...</a><br/></td></tr>
<tr class="separator:ga68b69dc86a88439f2880fa7eab00e6a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee8eca81a27f8e027d640b89bbd7324a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#gaee8eca81a27f8e027d640b89bbd7324a">SOL_USEC_PER_SEC</a>&#160;&#160;&#160;1000000ULL</td></tr>
<tr class="memdesc:gaee8eca81a27f8e027d640b89bbd7324a"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of microseconds in a second: 1,000,000.  <a href="#gaee8eca81a27f8e027d640b89bbd7324a">More...</a><br/></td></tr>
<tr class="separator:gaee8eca81a27f8e027d640b89bbd7324a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f589d46e205cd93bfb21f028f03c65b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga5f589d46e205cd93bfb21f028f03c65b">SOL_UTIL_ARRAY_SIZE</a>(arr)&#160;&#160;&#160;(sizeof(arr) / sizeof((arr)[0]))</td></tr>
<tr class="memdesc:ga5f589d46e205cd93bfb21f028f03c65b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the number of elements in an array.  <a href="#ga5f589d46e205cd93bfb21f028f03c65b">More...</a><br/></td></tr>
<tr class="separator:ga5f589d46e205cd93bfb21f028f03c65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab584188ab3f38605dab8b04aaa85913d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#gab584188ab3f38605dab8b04aaa85913d">sol_util_strerrora</a>(errnum)</td></tr>
<tr class="memdesc:gab584188ab3f38605dab8b04aaa85913d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a string from a given error using the stack.  <a href="#gab584188ab3f38605dab8b04aaa85913d">More...</a><br/></td></tr>
<tr class="separator:gab584188ab3f38605dab8b04aaa85913d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaa52ea19a1852e9e838a1ec40ffa39f30"><td class="memItemLeft" align="right" valign="top">static ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#gaa52ea19a1852e9e838a1ec40ffa39f30">sol_util_base16_calculate_decoded_len</a> (const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> slice)</td></tr>
<tr class="memdesc:gaa52ea19a1852e9e838a1ec40ffa39f30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the size necessary to decode a given slice in base16.  <a href="#gaa52ea19a1852e9e838a1ec40ffa39f30">More...</a><br/></td></tr>
<tr class="separator:gaa52ea19a1852e9e838a1ec40ffa39f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d9b7bbe9d55e8a0ef3c0685bae56625"><td class="memItemLeft" align="right" valign="top">static ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga1d9b7bbe9d55e8a0ef3c0685bae56625">sol_util_base16_calculate_encoded_len</a> (const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> slice)</td></tr>
<tr class="memdesc:ga1d9b7bbe9d55e8a0ef3c0685bae56625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the size necessary to encode a given slice in base16.  <a href="#ga1d9b7bbe9d55e8a0ef3c0685bae56625">More...</a><br/></td></tr>
<tr class="separator:ga1d9b7bbe9d55e8a0ef3c0685bae56625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4089d5876b27d70240b2ad07d4b6f64"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#gac4089d5876b27d70240b2ad07d4b6f64">sol_util_base16_decode</a> (void *buf, size_t buflen, const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> slice, enum <a class="el" href="group__Buffer.html#ga06c94d5ad12e5abae2f881a53c6becf8">sol_decode_case</a> decode_case)</td></tr>
<tr class="memdesc:gac4089d5876b27d70240b2ad07d4b6f64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the binary slice from base16 (hexadecimal).  <a href="#gac4089d5876b27d70240b2ad07d4b6f64">More...</a><br/></td></tr>
<tr class="separator:gac4089d5876b27d70240b2ad07d4b6f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42409b41553e6878466722ab17ddc27d"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga42409b41553e6878466722ab17ddc27d">sol_util_base16_encode</a> (void *buf, size_t buflen, const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> slice, bool uppercase)</td></tr>
<tr class="memdesc:ga42409b41553e6878466722ab17ddc27d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode the binary slice to base16 (hexadecimal).  <a href="#ga42409b41553e6878466722ab17ddc27d">More...</a><br/></td></tr>
<tr class="separator:ga42409b41553e6878466722ab17ddc27d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f2630baa157de5d41f25f527a185501"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga4f2630baa157de5d41f25f527a185501">sol_util_base64_calculate_decoded_len</a> (const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> slice, const char base64_map[<a class="el" href="group__Macros.html#ga38dd7c61af06bb93b22b32217dfa944d">SOL_STATIC_ARRAY_SIZE</a>(65)])</td></tr>
<tr class="memdesc:ga4f2630baa157de5d41f25f527a185501"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the size necessary to decode a given slice in base64.  <a href="#ga4f2630baa157de5d41f25f527a185501">More...</a><br/></td></tr>
<tr class="separator:ga4f2630baa157de5d41f25f527a185501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4177d45ab373433b10e72e059253b46d"><td class="memItemLeft" align="right" valign="top">static ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga4177d45ab373433b10e72e059253b46d">sol_util_base64_calculate_encoded_len</a> (const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> slice, const char base64_map[<a class="el" href="group__Macros.html#ga38dd7c61af06bb93b22b32217dfa944d">SOL_STATIC_ARRAY_SIZE</a>(65)])</td></tr>
<tr class="memdesc:ga4177d45ab373433b10e72e059253b46d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the size necessary to encode a given slice in base64.  <a href="#ga4177d45ab373433b10e72e059253b46d">More...</a><br/></td></tr>
<tr class="separator:ga4177d45ab373433b10e72e059253b46d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19e2b3856ee9a879658c868b80050970"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga19e2b3856ee9a879658c868b80050970">sol_util_base64_decode</a> (void *buf, size_t buflen, const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> slice, const char base64_map[<a class="el" href="group__Macros.html#ga38dd7c61af06bb93b22b32217dfa944d">SOL_STATIC_ARRAY_SIZE</a>(65)])</td></tr>
<tr class="memdesc:ga19e2b3856ee9a879658c868b80050970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the binary slice from base64 using the given map.  <a href="#ga19e2b3856ee9a879658c868b80050970">More...</a><br/></td></tr>
<tr class="separator:ga19e2b3856ee9a879658c868b80050970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7228f93dcb7e29a7eb594624265997d0"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga7228f93dcb7e29a7eb594624265997d0">sol_util_base64_encode</a> (void *buf, size_t buflen, const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> slice, const char base64_map[<a class="el" href="group__Macros.html#ga38dd7c61af06bb93b22b32217dfa944d">SOL_STATIC_ARRAY_SIZE</a>(65)])</td></tr>
<tr class="memdesc:ga7228f93dcb7e29a7eb594624265997d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode the binary slice to base64 using the given map.  <a href="#ga7228f93dcb7e29a7eb594624265997d0">More...</a><br/></td></tr>
<tr class="separator:ga7228f93dcb7e29a7eb594624265997d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0258d91cf52518556da4570df97abee"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#gaf0258d91cf52518556da4570df97abee">sol_util_be16_to_cpu</a> (uint16_t val)</td></tr>
<tr class="memdesc:gaf0258d91cf52518556da4570df97abee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a 16 bytes big endian integer to cpu endianness.  <a href="#gaf0258d91cf52518556da4570df97abee">More...</a><br/></td></tr>
<tr class="separator:gaf0258d91cf52518556da4570df97abee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacaa5f58ed390da32d8a8da3bb6b5a5b4"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#gacaa5f58ed390da32d8a8da3bb6b5a5b4">sol_util_be32_to_cpu</a> (uint32_t val)</td></tr>
<tr class="memdesc:gacaa5f58ed390da32d8a8da3bb6b5a5b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a 32 bytes big endian integer to cpu endianness.  <a href="#gacaa5f58ed390da32d8a8da3bb6b5a5b4">More...</a><br/></td></tr>
<tr class="separator:gacaa5f58ed390da32d8a8da3bb6b5a5b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a4d62e1f14e4ed9bebc91629e37fd5c"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga5a4d62e1f14e4ed9bebc91629e37fd5c">sol_util_be64_to_cpu</a> (uint64_t val)</td></tr>
<tr class="memdesc:ga5a4d62e1f14e4ed9bebc91629e37fd5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a 64 bytes big endian integer to cpu endianness.  <a href="#ga5a4d62e1f14e4ed9bebc91629e37fd5c">More...</a><br/></td></tr>
<tr class="separator:ga5a4d62e1f14e4ed9bebc91629e37fd5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga807cecfed816870ec5aad29126c3b9cc"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga807cecfed816870ec5aad29126c3b9cc">sol_util_cpu_to_be16</a> (uint16_t val)</td></tr>
<tr class="memdesc:ga807cecfed816870ec5aad29126c3b9cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a 16 bytes integer to big endian format.  <a href="#ga807cecfed816870ec5aad29126c3b9cc">More...</a><br/></td></tr>
<tr class="separator:ga807cecfed816870ec5aad29126c3b9cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46889a42b373c4ac375daa6768a41d2b"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga46889a42b373c4ac375daa6768a41d2b">sol_util_cpu_to_be32</a> (uint32_t val)</td></tr>
<tr class="memdesc:ga46889a42b373c4ac375daa6768a41d2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a 32 bytes integer to big endian format.  <a href="#ga46889a42b373c4ac375daa6768a41d2b">More...</a><br/></td></tr>
<tr class="separator:ga46889a42b373c4ac375daa6768a41d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f1258b67f97da5bc01852684c87e998"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga7f1258b67f97da5bc01852684c87e998">sol_util_cpu_to_be64</a> (uint64_t val)</td></tr>
<tr class="memdesc:ga7f1258b67f97da5bc01852684c87e998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a 64 bytes integer to big endian format.  <a href="#ga7f1258b67f97da5bc01852684c87e998">More...</a><br/></td></tr>
<tr class="separator:ga7f1258b67f97da5bc01852684c87e998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga006f1fe01c984b58a6445b5334234e66"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga006f1fe01c984b58a6445b5334234e66">sol_util_cpu_to_le16</a> (uint16_t val)</td></tr>
<tr class="memdesc:ga006f1fe01c984b58a6445b5334234e66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a 16 bytes integer to little endian format.  <a href="#ga006f1fe01c984b58a6445b5334234e66">More...</a><br/></td></tr>
<tr class="separator:ga006f1fe01c984b58a6445b5334234e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3b9c092ef1f91d460f88b2959c1705b"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#gac3b9c092ef1f91d460f88b2959c1705b">sol_util_cpu_to_le32</a> (uint32_t val)</td></tr>
<tr class="memdesc:gac3b9c092ef1f91d460f88b2959c1705b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a 32 bytes integer to little endian format.  <a href="#gac3b9c092ef1f91d460f88b2959c1705b">More...</a><br/></td></tr>
<tr class="separator:gac3b9c092ef1f91d460f88b2959c1705b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31039a248872ad9123ffb4d7dd09ebee"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga31039a248872ad9123ffb4d7dd09ebee">sol_util_cpu_to_le64</a> (uint64_t val)</td></tr>
<tr class="memdesc:ga31039a248872ad9123ffb4d7dd09ebee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a 64 bytes integer to little endian format.  <a href="#ga31039a248872ad9123ffb4d7dd09ebee">More...</a><br/></td></tr>
<tr class="separator:ga31039a248872ad9123ffb4d7dd09ebee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00b7c9cff6c5aaf0e76912637822b874"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga00b7c9cff6c5aaf0e76912637822b874">sol_util_double_equal</a> (double var0, double var1)</td></tr>
<tr class="memdesc:ga00b7c9cff6c5aaf0e76912637822b874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks <code>var0</code> and <code>var1</code> for equality.  <a href="#ga00b7c9cff6c5aaf0e76912637822b874">More...</a><br/></td></tr>
<tr class="separator:ga00b7c9cff6c5aaf0e76912637822b874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga148a2d09a5cb34ca70ba282eb67ddf8e"><td class="memItemLeft" align="right" valign="top">static int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga148a2d09a5cb34ca70ba282eb67ddf8e">sol_util_int32_clamp</a> (int32_t start, int32_t end, int32_t <a class="el" href="server_8c.html#acda54b23a3b92ae2efa63634288c0496">value</a>)</td></tr>
<tr class="memdesc:ga148a2d09a5cb34ca70ba282eb67ddf8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restricts a number between two other numbers.  <a href="#ga148a2d09a5cb34ca70ba282eb67ddf8e">More...</a><br/></td></tr>
<tr class="separator:ga148a2d09a5cb34ca70ba282eb67ddf8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc4f9ec9edf6bfb59c4624df85aaedda"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#gadc4f9ec9edf6bfb59c4624df85aaedda">sol_util_int32_mul</a> (const int32_t op1, const int32_t op2, int32_t *out)</td></tr>
<tr class="memdesc:gadc4f9ec9edf6bfb59c4624df85aaedda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two values checking for overflow.  <a href="#gadc4f9ec9edf6bfb59c4624df85aaedda">More...</a><br/></td></tr>
<tr class="separator:gadc4f9ec9edf6bfb59c4624df85aaedda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc6e58baced31712555921506ef15b60"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#gafc6e58baced31712555921506ef15b60">sol_util_int64_mul</a> (const int64_t op1, const int64_t op2, int64_t *out)</td></tr>
<tr class="memdesc:gafc6e58baced31712555921506ef15b60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two values checking for overflow.  <a href="#gafc6e58baced31712555921506ef15b60">More...</a><br/></td></tr>
<tr class="separator:gafc6e58baced31712555921506ef15b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64996cc23e42c0b4f31724082abd1899"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga64996cc23e42c0b4f31724082abd1899">sol_util_le16_to_cpu</a> (uint16_t val)</td></tr>
<tr class="memdesc:ga64996cc23e42c0b4f31724082abd1899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a 16 bytes little endian integer to cpu endianness.  <a href="#ga64996cc23e42c0b4f31724082abd1899">More...</a><br/></td></tr>
<tr class="separator:ga64996cc23e42c0b4f31724082abd1899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d7e7d152e57a0c330bd464cd3367ae8"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga8d7e7d152e57a0c330bd464cd3367ae8">sol_util_le32_to_cpu</a> (uint32_t val)</td></tr>
<tr class="memdesc:ga8d7e7d152e57a0c330bd464cd3367ae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a 32 bytes little endian integer to cpu endianness.  <a href="#ga8d7e7d152e57a0c330bd464cd3367ae8">More...</a><br/></td></tr>
<tr class="separator:ga8d7e7d152e57a0c330bd464cd3367ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2915c43bca876e9b81e9e1e15bdaebd"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#gae2915c43bca876e9b81e9e1e15bdaebd">sol_util_le64_to_cpu</a> (uint64_t val)</td></tr>
<tr class="memdesc:gae2915c43bca876e9b81e9e1e15bdaebd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a 64 bytes little endian integer to cpu endianness.  <a href="#gae2915c43bca876e9b81e9e1e15bdaebd">More...</a><br/></td></tr>
<tr class="separator:gae2915c43bca876e9b81e9e1e15bdaebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga803075d7e3b618971556ebed7615478e"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga803075d7e3b618971556ebed7615478e">sol_util_msec_from_timespec</a> (const struct timespec *ts)</td></tr>
<tr class="memdesc:ga803075d7e3b618971556ebed7615478e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of milliseconds for given time.  <a href="#ga803075d7e3b618971556ebed7615478e">More...</a><br/></td></tr>
<tr class="separator:ga803075d7e3b618971556ebed7615478e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ece69bf5fbb994a9610f155a320a165"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga0ece69bf5fbb994a9610f155a320a165">sol_util_replace_str_from_slice_if_changed</a> (char **str, const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> slice)</td></tr>
<tr class="memdesc:ga0ece69bf5fbb994a9610f155a320a165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the string's contents.  <a href="#ga0ece69bf5fbb994a9610f155a320a165">More...</a><br/></td></tr>
<tr class="separator:ga0ece69bf5fbb994a9610f155a320a165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67d3f4a639aca2702609ebec66677214"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga67d3f4a639aca2702609ebec66677214">sol_util_replace_str_if_changed</a> (char **str, const char *new_str)</td></tr>
<tr class="memdesc:ga67d3f4a639aca2702609ebec66677214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the string's contents.  <a href="#ga67d3f4a639aca2702609ebec66677214">More...</a><br/></td></tr>
<tr class="separator:ga67d3f4a639aca2702609ebec66677214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06615173ded23aee3f95aebf20b3ed4d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga06615173ded23aee3f95aebf20b3ed4d">sol_util_secure_clear_memory</a> (void *buf, size_t len)</td></tr>
<tr class="memdesc:ga06615173ded23aee3f95aebf20b3ed4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear an allocated memory securely.  <a href="#ga06615173ded23aee3f95aebf20b3ed4d">More...</a><br/></td></tr>
<tr class="separator:ga06615173ded23aee3f95aebf20b3ed4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fff2785485bc562c342fcbba51a183a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga1fff2785485bc562c342fcbba51a183a">sol_util_size_add</a> (const size_t op1, const size_t op2, size_t *out)</td></tr>
<tr class="memdesc:ga1fff2785485bc562c342fcbba51a183a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two values checking for overflow.  <a href="#ga1fff2785485bc562c342fcbba51a183a">More...</a><br/></td></tr>
<tr class="separator:ga1fff2785485bc562c342fcbba51a183a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae27ceaafd5444816bd9e239a67c1aa9e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#gae27ceaafd5444816bd9e239a67c1aa9e">sol_util_size_mul</a> (size_t op1, size_t op2, size_t *out)</td></tr>
<tr class="memdesc:gae27ceaafd5444816bd9e239a67c1aa9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two values checking for overflow.  <a href="#gae27ceaafd5444816bd9e239a67c1aa9e">More...</a><br/></td></tr>
<tr class="separator:gae27ceaafd5444816bd9e239a67c1aa9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0139defc74dab91612f178dbf900bd25"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga0139defc74dab91612f178dbf900bd25">sol_util_size_sub</a> (const size_t op1, const size_t op2, size_t *out)</td></tr>
<tr class="memdesc:ga0139defc74dab91612f178dbf900bd25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract two values checking for overflow.  <a href="#ga0139defc74dab91612f178dbf900bd25">More...</a><br/></td></tr>
<tr class="separator:ga0139defc74dab91612f178dbf900bd25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7880de7559ba11c37feba7328d5d789c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga7880de7559ba11c37feba7328d5d789c">sol_util_ssize_mul</a> (ssize_t op1, ssize_t op2, ssize_t *out)</td></tr>
<tr class="memdesc:ga7880de7559ba11c37feba7328d5d789c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two values checking for overflow.  <a href="#ga7880de7559ba11c37feba7328d5d789c">More...</a><br/></td></tr>
<tr class="separator:ga7880de7559ba11c37feba7328d5d789c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga599c379593c1d19c8d6fee209bfec6f3"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga599c379593c1d19c8d6fee209bfec6f3">sol_util_strerror</a> (int errnum, struct <a class="el" href="structsol__buffer.html">sol_buffer</a> *buf)</td></tr>
<tr class="memdesc:ga599c379593c1d19c8d6fee209bfec6f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a string from a given error.  <a href="#ga599c379593c1d19c8d6fee209bfec6f3">More...</a><br/></td></tr>
<tr class="separator:ga599c379593c1d19c8d6fee209bfec6f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6615620037e84c2b2a39515625e67185"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga6615620037e84c2b2a39515625e67185">sol_util_strtodn</a> (const char *nptr, char **endptr, ssize_t len, bool use_locale)</td></tr>
<tr class="memdesc:ga6615620037e84c2b2a39515625e67185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper over strtod() that consumes up to <code>len</code> bytes and may not use a locale.  <a href="#ga6615620037e84c2b2a39515625e67185">More...</a><br/></td></tr>
<tr class="separator:ga6615620037e84c2b2a39515625e67185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ab8fa1ccc09a1e269f31fd641ab5d76"><td class="memItemLeft" align="right" valign="top">long int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga7ab8fa1ccc09a1e269f31fd641ab5d76">sol_util_strtol</a> (const char *nptr, char **endptr, ssize_t len, int base)</td></tr>
<tr class="memdesc:ga7ab8fa1ccc09a1e269f31fd641ab5d76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper over strtol() that consumes up to <code>len</code> bytes.  <a href="#ga7ab8fa1ccc09a1e269f31fd641ab5d76">More...</a><br/></td></tr>
<tr class="separator:ga7ab8fa1ccc09a1e269f31fd641ab5d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01ab2aef1b60def573aeac72bf2c2e3a"><td class="memItemLeft" align="right" valign="top">unsigned long int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga01ab2aef1b60def573aeac72bf2c2e3a">sol_util_strtoul</a> (const char *nptr, char **endptr, ssize_t len, int base)</td></tr>
<tr class="memdesc:ga01ab2aef1b60def573aeac72bf2c2e3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper over strtoul() that consumes up to <code>len</code> bytes.  <a href="#ga01ab2aef1b60def573aeac72bf2c2e3a">More...</a><br/></td></tr>
<tr class="separator:ga01ab2aef1b60def573aeac72bf2c2e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga844d3517f1567c03759b6e9e5d7f8d9e"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga844d3517f1567c03759b6e9e5d7f8d9e">sol_util_timespec_compare</a> (const struct timespec *t1, const struct timespec *t2)</td></tr>
<tr class="memdesc:ga844d3517f1567c03759b6e9e5d7f8d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two time values.  <a href="#ga844d3517f1567c03759b6e9e5d7f8d9e">More...</a><br/></td></tr>
<tr class="separator:ga844d3517f1567c03759b6e9e5d7f8d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99b5073a0c2aafe1e8841ce46d0ff9a4"><td class="memItemLeft" align="right" valign="top">static struct timespec&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga99b5073a0c2aafe1e8841ce46d0ff9a4">sol_util_timespec_from_msec</a> (const int msec)</td></tr>
<tr class="memdesc:ga99b5073a0c2aafe1e8841ce46d0ff9a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <code>struct</code> timespec from milliseconds.  <a href="#ga99b5073a0c2aafe1e8841ce46d0ff9a4">More...</a><br/></td></tr>
<tr class="separator:ga99b5073a0c2aafe1e8841ce46d0ff9a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57ce4e370b335210cfc9f5b11c282c28"><td class="memItemLeft" align="right" valign="top">struct timespec&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga57ce4e370b335210cfc9f5b11c282c28">sol_util_timespec_get_current</a> (void)</td></tr>
<tr class="memdesc:ga57ce4e370b335210cfc9f5b11c282c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current time (Monotonic).  <a href="#ga57ce4e370b335210cfc9f5b11c282c28">More...</a><br/></td></tr>
<tr class="separator:ga57ce4e370b335210cfc9f5b11c282c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0000c794612dcaec7bfec8a10627576d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga0000c794612dcaec7bfec8a10627576d">sol_util_timespec_get_realtime</a> (struct timespec *t)</td></tr>
<tr class="memdesc:ga0000c794612dcaec7bfec8a10627576d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current time (System-wide clock).  <a href="#ga0000c794612dcaec7bfec8a10627576d">More...</a><br/></td></tr>
<tr class="separator:ga0000c794612dcaec7bfec8a10627576d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e029d247d32dd0d079d2e00f468cc9b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga8e029d247d32dd0d079d2e00f468cc9b">sol_util_timespec_sub</a> (const struct timespec *t1, const struct timespec *t2, struct timespec *result)</td></tr>
<tr class="memdesc:ga8e029d247d32dd0d079d2e00f468cc9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts two time values.  <a href="#ga8e029d247d32dd0d079d2e00f468cc9b">More...</a><br/></td></tr>
<tr class="separator:ga8e029d247d32dd0d079d2e00f468cc9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ee8d069432806f014f8770900ec1f80"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga0ee8d069432806f014f8770900ec1f80">sol_util_timespec_sum</a> (const struct timespec *t1, const struct timespec *t2, struct timespec *result)</td></tr>
<tr class="memdesc:ga0ee8d069432806f014f8770900ec1f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum two time values.  <a href="#ga0ee8d069432806f014f8770900ec1f80">More...</a><br/></td></tr>
<tr class="separator:ga0ee8d069432806f014f8770900ec1f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e1b201ade38f1cc2df0b58980eae5f1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga9e1b201ade38f1cc2df0b58980eae5f1">sol_util_uint32_mul</a> (const uint32_t op1, const uint32_t op2, uint32_t *out)</td></tr>
<tr class="memdesc:ga9e1b201ade38f1cc2df0b58980eae5f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two values checking for overflow.  <a href="#ga9e1b201ade38f1cc2df0b58980eae5f1">More...</a><br/></td></tr>
<tr class="separator:ga9e1b201ade38f1cc2df0b58980eae5f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga772ad9098c47ae26b734d38706be9690"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga772ad9098c47ae26b734d38706be9690">sol_util_uint64_add</a> (const uint64_t op1, const uint64_t op2, uint64_t *out)</td></tr>
<tr class="memdesc:ga772ad9098c47ae26b734d38706be9690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two values checking for overflow.  <a href="#ga772ad9098c47ae26b734d38706be9690">More...</a><br/></td></tr>
<tr class="separator:ga772ad9098c47ae26b734d38706be9690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga159157c3fcc383372a10d1cbb8c1cd1e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga159157c3fcc383372a10d1cbb8c1cd1e">sol_util_uint64_mul</a> (const uint64_t op1, const uint64_t op2, uint64_t *out)</td></tr>
<tr class="memdesc:ga159157c3fcc383372a10d1cbb8c1cd1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two values checking for overflow.  <a href="#ga159157c3fcc383372a10d1cbb8c1cd1e">More...</a><br/></td></tr>
<tr class="separator:ga159157c3fcc383372a10d1cbb8c1cd1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc7df6638697e10b7c02e5759ef2736c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#gafc7df6638697e10b7c02e5759ef2736c">sol_util_unescape_quotes</a> (const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> slice, struct <a class="el" href="structsol__buffer.html">sol_buffer</a> *buf)</td></tr>
<tr class="memdesc:gafc7df6638697e10b7c02e5759ef2736c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unescape a string removing quotes from it.  <a href="#gafc7df6638697e10b7c02e5759ef2736c">More...</a><br/></td></tr>
<tr class="separator:gafc7df6638697e10b7c02e5759ef2736c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga739423811b1b2bca8dc71e925ccd09aa"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga739423811b1b2bca8dc71e925ccd09aa">sol_util_unicode_code_from_utf8</a> (const uint8_t *buf, size_t buf_len, uint8_t *bytes_read)</td></tr>
<tr class="memdesc:ga739423811b1b2bca8dc71e925ccd09aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a utf-8 character to unicode code.  <a href="#ga739423811b1b2bca8dc71e925ccd09aa">More...</a><br/></td></tr>
<tr class="separator:ga739423811b1b2bca8dc71e925ccd09aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83d5b9e4ac3f4e96cf3b0df7d1c8edd3"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga83d5b9e4ac3f4e96cf3b0df7d1c8edd3">sol_util_utf8_from_unicode_code</a> (uint8_t *buf, size_t buf_len, uint32_t unicode_code)</td></tr>
<tr class="memdesc:ga83d5b9e4ac3f4e96cf3b0df7d1c8edd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert from unicode code to utf-8 string.  <a href="#ga83d5b9e4ac3f4e96cf3b0df7d1c8edd3">More...</a><br/></td></tr>
<tr class="separator:ga83d5b9e4ac3f4e96cf3b0df7d1c8edd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7524f20e61d21446bec34f910b426467"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga7524f20e61d21446bec34f910b426467">sol_util_uuid_gen</a> (bool upcase, bool with_hyphens, char id[<a class="el" href="group__Macros.html#ga38dd7c61af06bb93b22b32217dfa944d">SOL_STATIC_ARRAY_SIZE</a>(37)])</td></tr>
<tr class="memdesc:ga7524f20e61d21446bec34f910b426467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a new universally unique identifier (UUID) string.  <a href="#ga7524f20e61d21446bec34f910b426467">More...</a><br/></td></tr>
<tr class="separator:ga7524f20e61d21446bec34f910b426467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa45cf62af8d30b956e1fb12e61f647d2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#gaa45cf62af8d30b956e1fb12e61f647d2">sol_util_uuid_str_valid</a> (const char *str)</td></tr>
<tr class="memdesc:gaa45cf62af8d30b956e1fb12e61f647d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a given universally unique identifier (UUID), in string form, is valid.  <a href="#gaa45cf62af8d30b956e1fb12e61f647d2">More...</a><br/></td></tr>
<tr class="separator:gaa45cf62af8d30b956e1fb12e61f647d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Contains helpers to manipulate time, error code/string, overflows, encode/decode data and some converters. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gad443945ba007cd32410dcee65fa3c8f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOL_MSEC_PER_SEC&#160;&#160;&#160;1000ULL</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>number of milliseconds in a second: 1,000. </p>

<p>Referenced by <a class="el" href="group__Utils.html#ga803075d7e3b618971556ebed7615478e">sol_util_msec_from_timespec()</a>, and <a class="el" href="group__Utils.html#ga99b5073a0c2aafe1e8841ce46d0ff9a4">sol_util_timespec_from_msec()</a>.</p>

</div>
</div>
<a class="anchor" id="gafc59dcf2bc73c7064daf59a26fa65114"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOL_NSEC_PER_MSEC&#160;&#160;&#160;1000000ULL</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>number of nanoseconds in a milliseconds: 1,000,000,000 / 1,000 = 1,000,000. </p>

<p>Referenced by <a class="el" href="group__Utils.html#ga803075d7e3b618971556ebed7615478e">sol_util_msec_from_timespec()</a>, and <a class="el" href="group__Utils.html#ga99b5073a0c2aafe1e8841ce46d0ff9a4">sol_util_timespec_from_msec()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1fb4b46fdbc848b218900018782af213"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOL_NSEC_PER_SEC&#160;&#160;&#160;1000000000ULL</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>number of nanoseconds in a second: 1,000,000,000. </p>

<p>Referenced by <a class="el" href="message-digest_8c.html#a5366c50e85344eaf247246178b11bd5b">print_time()</a>, <a class="el" href="group__Utils.html#ga8e029d247d32dd0d079d2e00f468cc9b">sol_util_timespec_sub()</a>, and <a class="el" href="group__Utils.html#ga0ee8d069432806f014f8770900ec1f80">sol_util_timespec_sum()</a>.</p>

</div>
</div>
<a class="anchor" id="ga79e9522def5d06e917947f0d223aefce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOL_NSEC_PER_USEC&#160;&#160;&#160;1000ULL</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>number of nanoseconds in a microsecond: 1,000,000,000 / 1,000,000 = 1,000. </p>

</div>
</div>
<a class="anchor" id="ga75edadeb46b279bfcfdab26ca9fd62b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sol_uint16_bytes_swap</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">val</td><td>)</td>
          <td>&#160;&#160;&#160;((uint16_t)((((val) &gt;&gt; 8) &amp; 0xff) | (((val) &amp; 0xff) &lt;&lt; 8)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps the bytes of a 16 bytes unsigned int. </p>

<p>Referenced by <a class="el" href="group__Utils.html#gaf0258d91cf52518556da4570df97abee">sol_util_be16_to_cpu()</a>, <a class="el" href="group__Utils.html#ga807cecfed816870ec5aad29126c3b9cc">sol_util_cpu_to_be16()</a>, <a class="el" href="group__Utils.html#ga006f1fe01c984b58a6445b5334234e66">sol_util_cpu_to_le16()</a>, and <a class="el" href="group__Utils.html#ga64996cc23e42c0b4f31724082abd1899">sol_util_le16_to_cpu()</a>.</p>

</div>
</div>
<a class="anchor" id="gae7a585389facb08e97c35c1de254978c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sol_uint32_bytes_swap</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">val</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((uint32_t)((((val) &amp; 0xff000000) &gt;&gt; 24) | (((val) &amp; 0x00ff0000) &gt;&gt;  8) | \</div>
<div class="line">    (((val) &amp; 0x0000ff00) &lt;&lt;  8) | (((val) &amp; 0x000000ff) &lt;&lt; 24)))</div>
</div><!-- fragment -->
<p>Swaps the bytes of a 32 bytes unsigned int. </p>

<p>Referenced by <a class="el" href="group__Utils.html#gacaa5f58ed390da32d8a8da3bb6b5a5b4">sol_util_be32_to_cpu()</a>, <a class="el" href="group__Utils.html#ga46889a42b373c4ac375daa6768a41d2b">sol_util_cpu_to_be32()</a>, <a class="el" href="group__Utils.html#gac3b9c092ef1f91d460f88b2959c1705b">sol_util_cpu_to_le32()</a>, and <a class="el" href="group__Utils.html#ga8d7e7d152e57a0c330bd464cd3367ae8">sol_util_le32_to_cpu()</a>.</p>

</div>
</div>
<a class="anchor" id="ga68b69dc86a88439f2880fa7eab00e6a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sol_uint64_bytes_swap</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">val</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((uint64_t)((((val) &amp; 0xff00000000000000ull) &gt;&gt; 56) \</div>
<div class="line">    | (((val) &amp; 0x00ff000000000000ull) &gt;&gt; 40) | (((val) &amp; 0x0000ff0000000000ull) &gt;&gt; 24) \</div>
<div class="line">    | (((val) &amp; 0x000000ff00000000ull) &gt;&gt; 8) | (((val) &amp; 0x00000000ff000000ull) &lt;&lt; 8) \</div>
<div class="line">    | (((val) &amp; 0x0000000000ff0000ull) &lt;&lt; 24) | (((val) &amp; 0x000000000000ff00ull) &lt;&lt; 40) \</div>
<div class="line">    | (((val) &amp; 0x00000000000000ffull) &lt;&lt; 56)))</div>
</div><!-- fragment -->
<p>Swaps the bytes of a 32 bytes unsigned int. </p>

<p>Referenced by <a class="el" href="group__Utils.html#ga5a4d62e1f14e4ed9bebc91629e37fd5c">sol_util_be64_to_cpu()</a>, <a class="el" href="group__Utils.html#ga7f1258b67f97da5bc01852684c87e998">sol_util_cpu_to_be64()</a>, <a class="el" href="group__Utils.html#ga31039a248872ad9123ffb4d7dd09ebee">sol_util_cpu_to_le64()</a>, and <a class="el" href="group__Utils.html#gae2915c43bca876e9b81e9e1e15bdaebd">sol_util_le64_to_cpu()</a>.</p>

</div>
</div>
<a class="anchor" id="gaee8eca81a27f8e027d640b89bbd7324a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOL_USEC_PER_SEC&#160;&#160;&#160;1000000ULL</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>number of microseconds in a second: 1,000,000. </p>

</div>
</div>
<a class="anchor" id="ga5f589d46e205cd93bfb21f028f03c65b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOL_UTIL_ARRAY_SIZE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">arr</td><td>)</td>
          <td>&#160;&#160;&#160;(sizeof(arr) / sizeof((arr)[0]))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the number of elements in an array. </p>

<p>Referenced by <a class="el" href="lwm2m-server_8c.html#a41f1e01b439e15b60cf5730152a9e2e2">create_location_obj()</a>.</p>

</div>
</div>
<a class="anchor" id="gab584188ab3f38605dab8b04aaa85913d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sol_util_strerrora</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">errnum</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">({ <a class="code" href="group__Buffer.html#ga397dbea3989940ad0d1243983a7a2204">\</a></div>
<div class="line"><a class="code" href="group__Buffer.html#ga397dbea3989940ad0d1243983a7a2204">        SOL_BUFFER_DECLARE_STATIC</a>(buf ## __COUNT__, 512); <a class="code" href="group__Utils.html#ga599c379593c1d19c8d6fee209bfec6f3">\</a></div>
<div class="line"><a class="code" href="group__Utils.html#ga599c379593c1d19c8d6fee209bfec6f3">        sol_util_strerror</a>((errnum), &amp;buf ## __COUNT__); \</div>
<div class="line">    })</div>
<div class="ttc" id="group__Buffer_html_ga397dbea3989940ad0d1243983a7a2204"><div class="ttname"><a href="group__Buffer.html#ga397dbea3989940ad0d1243983a7a2204">SOL_BUFFER_DECLARE_STATIC</a></div><div class="ttdeci">#define SOL_BUFFER_DECLARE_STATIC(name_, size_)</div><div class="ttdoc">A helper macro to create a static allocated buffer with a fixed capacity. </div><div class="ttdef"><b>Definition:</b> sol-buffer.h:194</div></div>
<div class="ttc" id="group__Utils_html_ga599c379593c1d19c8d6fee209bfec6f3"><div class="ttname"><a href="group__Utils.html#ga599c379593c1d19c8d6fee209bfec6f3">sol_util_strerror</a></div><div class="ttdeci">char * sol_util_strerror(int errnum, struct sol_buffer *buf)</div><div class="ttdoc">Gets a string from a given error. </div></div>
</div><!-- fragment -->
<p>Gets a string from a given error using the stack. </p>
<p>The function returns a pointer to a string (created using the stack) that describes the error code passed in the argument <code>errnum</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">errnum</td><td>The error code</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the appropriate error description string.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Utils.html#ga599c379593c1d19c8d6fee209bfec6f3" title="Gets a string from a given error. ">sol_util_strerror</a> </dd></dl>

<p>Referenced by <a class="el" href="single-node_8c.html#a558a1a7f379d050200743d2bcb5fb620">get_int32_packet_and_log()</a>, <a class="el" href="basic_8c.html#ad29bbe8a9dce491f048c1aa22021fe15">mavlink_connect_cb()</a>, <a class="el" href="basic_8c.html#ab34b282da15b5a49106699ddd559b52e">mission_reached_cb()</a>, <a class="el" href="basic_8c.html#ab0c64db3ed9f0c3d4df2cffa279e12cc">mode_changed_cb()</a>, <a class="el" href="server_8c.html#ae15b6636fe22ea3bfcca92f512cbf3db">on_stdin()</a>, <a class="el" href="sha256sum_8c.html#afc7855e4b6972e4d50f909d42dd67776">on_stdin_hash()</a>, <a class="el" href="basic_8c.html#a36dfa5adb36c28f7c4648de2f3bf11fd">position_changed_cb()</a>, <a class="el" href="message-digest_8c.html#a8f65ca9f5a72be7fe776126fc632f8a9">startup()</a>, and <a class="el" href="basic_8c.html#acc98c288a5a11d0ada82dd7bd1c164f8">takeoff()</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaa52ea19a1852e9e838a1ec40ffa39f30"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ssize_t sol_util_base16_calculate_decoded_len </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a>&#160;</td>
          <td class="paramname"><em>slice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the size necessary to decode a given slice in base16. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>The slice that is wanted to know the decoded size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size that will be utilized to decode the <code>slice</code> or a negative number on error. </dd></dl>

<p>References <a class="el" href="structsol__str__slice.html#a9b9f38d8d946af896daf76fab04473b7">sol_str_slice::len</a>.</p>

</div>
</div>
<a class="anchor" id="ga1d9b7bbe9d55e8a0ef3c0685bae56625"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ssize_t sol_util_base16_calculate_encoded_len </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a>&#160;</td>
          <td class="paramname"><em>slice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the size necessary to encode a given slice in base16. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>The slice that is wanted to know the encoded size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size that will be utilized to encode the <code>slice</code> or a negative number on error. </dd></dl>

<p>References <a class="el" href="structsol__str__slice.html#a9b9f38d8d946af896daf76fab04473b7">sol_str_slice::len</a>, and <a class="el" href="group__Utils.html#ga7880de7559ba11c37feba7328d5d789c">sol_util_ssize_mul()</a>.</p>

</div>
</div>
<a class="anchor" id="gac4089d5876b27d70240b2ad07d4b6f64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t sol_util_base16_decode </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buflen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a>&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__Buffer.html#ga06c94d5ad12e5abae2f881a53c6becf8">sol_decode_case</a>&#160;</td>
          <td class="paramname"><em>decode_case</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode the binary slice from base16 (hexadecimal). </p>
<dl class="section note"><dt>Note</dt><dd><b>no</b> trailing null '\0' is added!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>a buffer of size <em>buflen</em> that is big enough to hold the decoded string. </td></tr>
    <tr><td class="paramname">buflen</td><td>the number of bytes available in buffer. Must be large enough to contain the decoded slice, that is: slice.len / 2. </td></tr>
    <tr><td class="paramname">slice</td><td>the slice to decode, it must be a set of 0-9 or letters A-F (if uppercase) or a-f, otherwise decode fails. </td></tr>
    <tr><td class="paramname">decode_case</td><td>if SOL_DECODE_UPPERCASE, uppercase letters ABCDEF are used, if SOL_DECODE_LOWERCASE, lowercase abcdef are used instead. If SOL_DECODE_BOTH both, lowercase and uppercase, letters can be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes written or -errno if failed. </dd></dl>

</div>
</div>
<a class="anchor" id="ga42409b41553e6878466722ab17ddc27d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t sol_util_base16_encode </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buflen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a>&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>uppercase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode the binary slice to base16 (hexadecimal). </p>
<dl class="section note"><dt>Note</dt><dd><b>no</b> trailing null '\0' is added!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>a buffer of size <em>buflen</em> that is big enough to hold the encoded string. </td></tr>
    <tr><td class="paramname">buflen</td><td>the number of bytes available in buffer. Must be large enough to contain the encoded slice, that is: slice.len * 2 </td></tr>
    <tr><td class="paramname">slice</td><td>the slice to encode, it may contain null-bytes (\0), the whole size of the slice will be used (slice.len). </td></tr>
    <tr><td class="paramname">uppercase</td><td>if true, uppercase letters ABCDEF are used, otherwise lowercase abcdef are used instead.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes written or -errno if failed. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4f2630baa157de5d41f25f527a185501"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t sol_util_base64_calculate_decoded_len </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a>&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>base64_map</em>[SOL_STATIC_ARRAY_SIZE(65)]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the size necessary to decode a given slice in base64. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>The slice that is wanted to know the decode size. </td></tr>
    <tr><td class="paramname">base64_map</td><td>the map to use. The last char is used as the padding character if slice length is not multiple of 3 bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size that will be utilized to decode the <code>slice</code> or a negative number on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4177d45ab373433b10e72e059253b46d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ssize_t sol_util_base64_calculate_encoded_len </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a>&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>base64_map</em>[SOL_STATIC_ARRAY_SIZE(65)]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the size necessary to encode a given slice in base64. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>The slice that is wanted to know the encoded size. </td></tr>
    <tr><td class="paramname">base64_map</td><td>the map to use. The last char is used as the padding character if slice length is not multiple of 3 bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size that will be utilized to encode the <code>slice</code> or a negative number on error. </dd></dl>

<p>References <a class="el" href="structsol__str__slice.html#a9b9f38d8d946af896daf76fab04473b7">sol_str_slice::len</a>, and <a class="el" href="group__Utils.html#ga7880de7559ba11c37feba7328d5d789c">sol_util_ssize_mul()</a>.</p>

</div>
</div>
<a class="anchor" id="ga19e2b3856ee9a879658c868b80050970"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t sol_util_base64_decode </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buflen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a>&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>base64_map</em>[SOL_STATIC_ARRAY_SIZE(65)]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode the binary slice from base64 using the given map. </p>
<p><a href="https://en.wikipedia.org/wiki/Base64">https://en.wikipedia.org/wiki/Base64</a></p>
<dl class="section note"><dt>Note</dt><dd><b>no</b> trailing null '\0' is added!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>a buffer of size <em>buflen</em> that is big enough to hold the decoded string. </td></tr>
    <tr><td class="paramname">buflen</td><td>the number of bytes available in buffer. Must be large enough to contain the decoded slice, that is: (slice.len / 4) * 3 </td></tr>
    <tr><td class="paramname">slice</td><td>the slice to decode, it must be composed solely of the base64_map characters or it will fail. </td></tr>
    <tr><td class="paramname">base64_map</td><td>the map to use. The last char is used as the padding character if slice length is not multiple of 3 bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes written or -errno if failed. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7228f93dcb7e29a7eb594624265997d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t sol_util_base64_encode </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buflen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a>&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>base64_map</em>[SOL_STATIC_ARRAY_SIZE(65)]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode the binary slice to base64 using the given map. </p>
<p><a href="https://en.wikipedia.org/wiki/Base64">https://en.wikipedia.org/wiki/Base64</a></p>
<dl class="section note"><dt>Note</dt><dd><b>no</b> trailing null '\0' is added!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>a buffer of size <em>buflen</em> that is big enough to hold the encoded string. </td></tr>
    <tr><td class="paramname">buflen</td><td>the number of bytes available in buffer. Must be large enough to contain the encoded slice, that is: (slice.len / 3 + 1) * 4 </td></tr>
    <tr><td class="paramname">slice</td><td>the slice to encode, it may contain null-bytes (\0), the whole size of the slice will be used (slice.len). </td></tr>
    <tr><td class="paramname">base64_map</td><td>the map to use. The last char is used as the padding character if slice length is not multiple of 3 bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes written or -errno if failed. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf0258d91cf52518556da4570df97abee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t sol_util_be16_to_cpu </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a 16 bytes big endian integer to cpu endianness. </p>
<p>This function converts a integer of 16 bytes to little endian format, in case of the integer being in the cpu endiannesst nothing is done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the uint16_t number to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the given value on little endian format.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Utils.html#ga64996cc23e42c0b4f31724082abd1899" title="Convert a 16 bytes little endian integer to cpu endianness. ">sol_util_le16_to_cpu</a> </dd></dl>

<p>References <a class="el" href="group__Utils.html#ga75edadeb46b279bfcfdab26ca9fd62b1">sol_uint16_bytes_swap</a>.</p>

</div>
</div>
<a class="anchor" id="gacaa5f58ed390da32d8a8da3bb6b5a5b4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t sol_util_be32_to_cpu </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a 32 bytes big endian integer to cpu endianness. </p>
<p>This function converts a integer of 32 bytes to little endian format, in case of the integer being in the cpu endiannesst nothing is done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the uint32_t number to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the given value on little endian format.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Utils.html#ga8d7e7d152e57a0c330bd464cd3367ae8" title="Convert a 32 bytes little endian integer to cpu endianness. ">sol_util_le32_to_cpu</a> </dd></dl>

<p>References <a class="el" href="group__Utils.html#gae7a585389facb08e97c35c1de254978c">sol_uint32_bytes_swap</a>.</p>

</div>
</div>
<a class="anchor" id="ga5a4d62e1f14e4ed9bebc91629e37fd5c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t sol_util_be64_to_cpu </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a 64 bytes big endian integer to cpu endianness. </p>
<p>This function converts a integer of 64 bytes to little endian format, in case of the integer being in the cpu endiannesst nothing is done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the uint64_t number to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the given value on little endian format.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Utils.html#gae2915c43bca876e9b81e9e1e15bdaebd" title="Convert a 64 bytes little endian integer to cpu endianness. ">sol_util_le64_to_cpu</a> </dd></dl>

<p>References <a class="el" href="group__Utils.html#ga68b69dc86a88439f2880fa7eab00e6a8">sol_uint64_bytes_swap</a>.</p>

</div>
</div>
<a class="anchor" id="ga807cecfed816870ec5aad29126c3b9cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t sol_util_cpu_to_be16 </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a 16 bytes integer to big endian format. </p>
<p>This function converts a integer of 16 bytes to big endian format, in case of the integer being in big endian format nothing is done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the uint16_t number to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the given value on big endian format.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Utils.html#ga006f1fe01c984b58a6445b5334234e66" title="Convert a 16 bytes integer to little endian format. ">sol_util_cpu_to_le16</a> </dd></dl>

<p>References <a class="el" href="group__Utils.html#ga75edadeb46b279bfcfdab26ca9fd62b1">sol_uint16_bytes_swap</a>.</p>

</div>
</div>
<a class="anchor" id="ga46889a42b373c4ac375daa6768a41d2b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t sol_util_cpu_to_be32 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a 32 bytes integer to big endian format. </p>
<p>This function converts a integer of 32 bytes to big endian format, in case of the integer being in big endian format nothing is done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the uint32_t number to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the given value on big endian format.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Utils.html#gac3b9c092ef1f91d460f88b2959c1705b" title="Convert a 32 bytes integer to little endian format. ">sol_util_cpu_to_le32</a> </dd></dl>

<p>References <a class="el" href="group__Utils.html#gae7a585389facb08e97c35c1de254978c">sol_uint32_bytes_swap</a>.</p>

</div>
</div>
<a class="anchor" id="ga7f1258b67f97da5bc01852684c87e998"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t sol_util_cpu_to_be64 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a 64 bytes integer to big endian format. </p>
<p>This function converts a integer of 64 bytes to big endian format, in case of the integer being in big endian format nothing is done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the uint64_t number to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the given value on big endian format.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Utils.html#ga31039a248872ad9123ffb4d7dd09ebee" title="Convert a 64 bytes integer to little endian format. ">sol_util_cpu_to_le64</a> </dd></dl>

<p>References <a class="el" href="group__Utils.html#ga68b69dc86a88439f2880fa7eab00e6a8">sol_uint64_bytes_swap</a>.</p>

</div>
</div>
<a class="anchor" id="ga006f1fe01c984b58a6445b5334234e66"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t sol_util_cpu_to_le16 </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a 16 bytes integer to little endian format. </p>
<p>This function converts a integer of 16 bytes to little endian format, in case of the integer being in little endian format nothing is done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the uint16_t number to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the given value on little endian format.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Utils.html#ga807cecfed816870ec5aad29126c3b9cc" title="Convert a 16 bytes integer to big endian format. ">sol_util_cpu_to_be16</a> </dd></dl>

<p>References <a class="el" href="group__Utils.html#ga75edadeb46b279bfcfdab26ca9fd62b1">sol_uint16_bytes_swap</a>.</p>

</div>
</div>
<a class="anchor" id="gac3b9c092ef1f91d460f88b2959c1705b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t sol_util_cpu_to_le32 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a 32 bytes integer to little endian format. </p>
<p>This function converts a integer of 32 bytes to little endian format, in case of the integer being in little endian format nothing is done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the uint32_t number to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the given value on little endian format.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Utils.html#ga46889a42b373c4ac375daa6768a41d2b" title="Convert a 32 bytes integer to big endian format. ">sol_util_cpu_to_be32</a> </dd></dl>

<p>References <a class="el" href="group__Utils.html#gae7a585389facb08e97c35c1de254978c">sol_uint32_bytes_swap</a>.</p>

</div>
</div>
<a class="anchor" id="ga31039a248872ad9123ffb4d7dd09ebee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t sol_util_cpu_to_le64 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a 64 bytes integer to little endian format. </p>
<p>This function converts a integer of 64 bytes to little endian format, in case of the integer being in little endian format nothing is done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the uint64_t number to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the given value on little endian format.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Utils.html#ga7f1258b67f97da5bc01852684c87e998" title="Convert a 64 bytes integer to big endian format. ">sol_util_cpu_to_be64</a> </dd></dl>

<p>References <a class="el" href="group__Utils.html#ga68b69dc86a88439f2880fa7eab00e6a8">sol_uint64_bytes_swap</a>.</p>

</div>
</div>
<a class="anchor" id="ga00b7c9cff6c5aaf0e76912637822b874"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sol_util_double_equal </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>var0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>var1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks <code>var0</code> and <code>var1</code> for equality. </p>
<p>It uses relative comparison to account for impressions caused by floating point arithmetics, so give preference to use this function instead of comparing the numbers directly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var0</td><td>First argument </td></tr>
    <tr><td class="paramname">var1</td><td>Second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if both values are equal, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga148a2d09a5cb34ca70ba282eb67ddf8e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int32_t sol_util_int32_clamp </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restricts a number between two other numbers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>Minimum value. </td></tr>
    <tr><td class="paramname">end</td><td>Maximum value. </td></tr>
    <tr><td class="paramname">value</td><td>The value to clamp.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>value</code> if living in the range imposed by the <code>start</code> and <code>end</code>, the lower value if initially lower than <code>start</code>, or the higher one if initially higher than <code>end</code>. </dd></dl>

<p>References <a class="el" href="server_8c.html#acda54b23a3b92ae2efa63634288c0496">value</a>.</p>

</div>
</div>
<a class="anchor" id="gadc4f9ec9edf6bfb59c4624df85aaedda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sol_util_int32_mul </td>
          <td>(</td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>op2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply two values checking for overflow. </p>
<p>This function multiplies two variables of the type <code>int32_t</code> and check if this operation causes an overflow.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op1</td><td>First operation's operator. </td></tr>
    <tr><td class="paramname">op2</td><td>Second operation's operator. </td></tr>
    <tr><td class="paramname">out</td><td>Variable used to store the result.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0</code> on success, error code (always negative) otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="gafc6e58baced31712555921506ef15b60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sol_util_int64_mul </td>
          <td>(</td>
          <td class="paramtype">const int64_t&#160;</td>
          <td class="paramname"><em>op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t&#160;</td>
          <td class="paramname"><em>op2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply two values checking for overflow. </p>
<p>This function multiply two variables of the type <code>int64_t</code> and check if this operation causes an overflow.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op1</td><td>First operation's operator. </td></tr>
    <tr><td class="paramname">op2</td><td>Second operation's operator. </td></tr>
    <tr><td class="paramname">out</td><td>Variable used to store the result.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0</code> on success, error code (always negative) otherwise.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Utils.html#ga159157c3fcc383372a10d1cbb8c1cd1e" title="Multiply two values checking for overflow. ">sol_util_uint64_mul</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga64996cc23e42c0b4f31724082abd1899"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t sol_util_le16_to_cpu </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a 16 bytes little endian integer to cpu endianness. </p>
<p>This function converts a integer of 16 bytes to little endian format, in case of the integer being in the cpu endianness nothing is done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the uint16_t number to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the given value on little endian format.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Utils.html#gaf0258d91cf52518556da4570df97abee" title="Convert a 16 bytes big endian integer to cpu endianness. ">sol_util_be16_to_cpu</a> </dd></dl>

<p>References <a class="el" href="group__Utils.html#ga75edadeb46b279bfcfdab26ca9fd62b1">sol_uint16_bytes_swap</a>.</p>

</div>
</div>
<a class="anchor" id="ga8d7e7d152e57a0c330bd464cd3367ae8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t sol_util_le32_to_cpu </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a 32 bytes little endian integer to cpu endianness. </p>
<p>This function converts a integer of 32 bytes to little endian format, in case of the integer being in the cpu endianness nothing is done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the uint32_t number to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the given value on little endian format.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Utils.html#gacaa5f58ed390da32d8a8da3bb6b5a5b4" title="Convert a 32 bytes big endian integer to cpu endianness. ">sol_util_be32_to_cpu</a> </dd></dl>

<p>References <a class="el" href="group__Utils.html#gae7a585389facb08e97c35c1de254978c">sol_uint32_bytes_swap</a>.</p>

</div>
</div>
<a class="anchor" id="gae2915c43bca876e9b81e9e1e15bdaebd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t sol_util_le64_to_cpu </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a 64 bytes little endian integer to cpu endianness. </p>
<p>This function converts a integer of 64 bytes to little endian format, in case of the integer being in the cpu endianness nothing is done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the uint64_t number to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the given value on little endian format.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Utils.html#ga5a4d62e1f14e4ed9bebc91629e37fd5c" title="Convert a 64 bytes big endian integer to cpu endianness. ">sol_util_be64_to_cpu</a> </dd></dl>

<p>References <a class="el" href="group__Utils.html#ga68b69dc86a88439f2880fa7eab00e6a8">sol_uint64_bytes_swap</a>.</p>

</div>
</div>
<a class="anchor" id="ga803075d7e3b618971556ebed7615478e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int sol_util_msec_from_timespec </td>
          <td>(</td>
          <td class="paramtype">const struct timespec *&#160;</td>
          <td class="paramname"><em>ts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of milliseconds for given time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ts</td><td>The struct timespec to get the milliseconds.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of milliseconds on <code>ts</code>. </dd></dl>

<p>References <a class="el" href="group__Utils.html#gad443945ba007cd32410dcee65fa3c8f8">SOL_MSEC_PER_SEC</a>, and <a class="el" href="group__Utils.html#gafc59dcf2bc73c7064daf59a26fa65114">SOL_NSEC_PER_MSEC</a>.</p>

</div>
</div>
<a class="anchor" id="ga0ece69bf5fbb994a9610f155a320a165"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sol_util_replace_str_from_slice_if_changed </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a>&#160;</td>
          <td class="paramname"><em>slice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the string's contents. </p>
<p>This function takes a string and replace its contents if different from the new given slice, otherwise it lets the string intact.</p>
<dl class="section note"><dt>Note</dt><dd>If the string is replaced its memory is properly released.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The pointer for string which will be changed. </td></tr>
    <tr><td class="paramname">slice</td><td>The slice with string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if changed, 0 if unchanged, error code (always negative) otherwise.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>util_replace_str_from_slice_if_changed </dd></dl>

</div>
</div>
<a class="anchor" id="ga67d3f4a639aca2702609ebec66677214"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sol_util_replace_str_if_changed </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>new_str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the string's contents. </p>
<p>This function takes a string and replace its contents if different from the new given string, otherwise it lets the string intact.</p>
<dl class="section note"><dt>Note</dt><dd>If the string is replaced its memory is properly released.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The pointer for string which will be changed. </td></tr>
    <tr><td class="paramname">new_str</td><td>The new string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if changed, 0 if unchanged, error code (always negative) otherwise.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>util_replace_str_from_slice_if_changed </dd></dl>

</div>
</div>
<a class="anchor" id="ga06615173ded23aee3f95aebf20b3ed4d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void sol_util_secure_clear_memory </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear an allocated memory securely. </p>
<p>Clobber memory pointed to by <code>buf</code> to prevent the optimizer from eliding the <code>memset()</code> call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The memory block </td></tr>
    <tr><td class="paramname">len</td><td>The buf length </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1fff2785485bc562c342fcbba51a183a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sol_util_size_add </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>op2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add two values checking for overflow. </p>
<p>This function adds two variables of the type <code>size_t</code> and check if this operation causes an overflow.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op1</td><td>First operation's operator. </td></tr>
    <tr><td class="paramname">op2</td><td>Second operation's operator. </td></tr>
    <tr><td class="paramname">out</td><td>Variable used to store the result.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0</code> on success, error code (always negative) otherwise.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Utils.html#ga0139defc74dab91612f178dbf900bd25" title="Subtract two values checking for overflow. ">sol_util_size_sub</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gae27ceaafd5444816bd9e239a67c1aa9e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sol_util_size_mul </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>op2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply two values checking for overflow. </p>
<p>This function multiply two variables of the type <code>size_t</code> and check if this operation causes an overflow.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op1</td><td>First operation's operator. </td></tr>
    <tr><td class="paramname">op2</td><td>Second operation's operator. </td></tr>
    <tr><td class="paramname">out</td><td>Variable used to store the time.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0</code> on success, error code (always negative) otherwise.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Utils.html#ga7880de7559ba11c37feba7328d5d789c" title="Multiply two values checking for overflow. ">sol_util_ssize_mul</a> </dd></dl>

<p>Referenced by <a class="el" href="sol-glib-integration_8h.html#a47d65d9a67a44844b350f7e916f3f060">_sol_glib_integration_source_prepare()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0139defc74dab91612f178dbf900bd25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sol_util_size_sub </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>op2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtract two values checking for overflow. </p>
<p>This function subtracts two variables of the type <code>size_t</code> and check if this operation causes an overflow.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op1</td><td>First operation's operator. </td></tr>
    <tr><td class="paramname">op2</td><td>Second operation's operator. </td></tr>
    <tr><td class="paramname">out</td><td>Variable used to store the result.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0</code> on success, error code (always negative) otherwise.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Utils.html#ga1fff2785485bc562c342fcbba51a183a" title="Add two values checking for overflow. ">sol_util_size_add</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga7880de7559ba11c37feba7328d5d789c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sol_util_ssize_mul </td>
          <td>(</td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>op2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssize_t *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply two values checking for overflow. </p>
<p>This function multiply two variables of the type <code>ssize_t</code> and check if this operation causes an overflow.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op1</td><td>First operation's operator. </td></tr>
    <tr><td class="paramname">op2</td><td>Second operation's operator. </td></tr>
    <tr><td class="paramname">out</td><td>Variable used to store the result.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0</code> on success, error code (always negative) otherwise.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Utils.html#gae27ceaafd5444816bd9e239a67c1aa9e" title="Multiply two values checking for overflow. ">sol_util_size_mul</a> </dd></dl>

<p>Referenced by <a class="el" href="group__Utils.html#ga1d9b7bbe9d55e8a0ef3c0685bae56625">sol_util_base16_calculate_encoded_len()</a>, and <a class="el" href="group__Utils.html#ga4177d45ab373433b10e72e059253b46d">sol_util_base64_calculate_encoded_len()</a>.</p>

</div>
</div>
<a class="anchor" id="ga599c379593c1d19c8d6fee209bfec6f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* sol_util_strerror </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>errnum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsol__buffer.html">sol_buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a string from a given error. </p>
<p>The function returns a pointer to a string that describes the error code passed in the argument <code>errnum</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">errnum</td><td>The error code </td></tr>
    <tr><td class="paramname">buf</td><td>Buffer used to append error the string - It must be already initialized.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return the appropriate error description string.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Utils.html#gab584188ab3f38605dab8b04aaa85913d" title="Gets a string from a given error using the stack. ">sol_util_strerrora</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga6615620037e84c2b2a39515625e67185"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double sol_util_strtodn </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>endptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_locale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper over strtod() that consumes up to <code>len</code> bytes and may not use a locale. </p>
<p>This variation of strtod() will work with buffers that are not null-terminated.</p>
<p>It also offers a way to skip the currently set locale, forcing plain "C". This is required to parse numbers in formats that require '.' as the decimal point while the current locale may use ',' such as in pt_BR.</p>
<p>All the formats accepted by strtod() are accepted and the behavior should be the same, including using information from <code>LC_NUMERIC</code> if locale is configured and <em>use_locale</em> is true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nptr</td><td>the string containing the number to convert. </td></tr>
    <tr><td class="paramname">endptr</td><td>if non-NULL, it will contain the last character used in the conversion. If no conversion was done, endptr is <em>nptr</em>. </td></tr>
    <tr><td class="paramname">use_locale</td><td>if true, then current locale is used, if false then "C" locale is forced.</td></tr>
    <tr><td class="paramname">len</td><td>use at most this amount of bytes of <em>nptr</em>. If -1, assumes nptr has a trailing NUL and calculate the string length.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the converted value, if any. The converted value may be <code>NAN</code>, <code>INF</code> (positive or negative). See the strtod(3) documentation for the details. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7ab8fa1ccc09a1e269f31fd641ab5d76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long int sol_util_strtol </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>endptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper over strtol() that consumes up to <code>len</code> bytes. </p>
<p>This variation of strtol() will work with buffers that are not null-terminated.</p>
<p>All the formats accepted by strtol() are accepted and the behavior should be the same.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nptr</td><td>the string containing the number to convert.</td></tr>
    <tr><td class="paramname">endptr</td><td>if non-NULL, it will contain the last character used in the conversion. If no conversion was done, endptr is <em>nptr</em>.</td></tr>
    <tr><td class="paramname">len</td><td>use at most this amount of bytes of <em>nptr</em>. If -1, assumes nptr has a trailing NUL and calculate the string length.</td></tr>
    <tr><td class="paramname">base</td><td>it's the base of convertion, which must be between 2 and 36 inclusive, or be the special value 0. A zero base is taken as 10 (decimal) unless the next character is '0', in which case it is taken as 8 (octal).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the converted value, if any. </dd></dl>

</div>
</div>
<a class="anchor" id="ga01ab2aef1b60def573aeac72bf2c2e3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long int sol_util_strtoul </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>endptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper over strtoul() that consumes up to <code>len</code> bytes. </p>
<p>This variation of strtoul() will work with buffers that are not null-terminated.</p>
<p>All the formats accepted by strtoul() are accepted and the behavior should be the same.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nptr</td><td>the string containing the number to convert.</td></tr>
    <tr><td class="paramname">endptr</td><td>if non-NULL, it will contain the last character used in the conversion. If no conversion was done, endptr is <em>nptr</em>.</td></tr>
    <tr><td class="paramname">len</td><td>use at most this amount of bytes of <em>nptr</em>. If -1, assumes nptr has a trailing NUL and calculate the string length.</td></tr>
    <tr><td class="paramname">base</td><td>it's the base of convertion, which must be between 2 and 36 inclusive, or be the special value 0. A zero base is taken as 10 (decimal) unless the next character is '0', in which case it is taken as 8 (octal).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the converted value, if any. </dd></dl>

</div>
</div>
<a class="anchor" id="ga844d3517f1567c03759b6e9e5d7f8d9e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int sol_util_timespec_compare </td>
          <td>(</td>
          <td class="paramtype">const struct timespec *&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timespec *&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two time values. </p>
<p>Function to compare two times. It returns an integer less than, equal to, or greater than zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t1</td><td>First time value used on operation. </td></tr>
    <tr><td class="paramname">t2</td><td>Second time value used on operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if equal, -1 if t2 is greater or 1 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga99b5073a0c2aafe1e8841ce46d0ff9a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static struct timespec sol_util_timespec_from_msec </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>msec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a <code>struct</code> timespec from milliseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msec</td><td>The number of milliseconds.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <code>struct</code> timespec representing <code>msec</code> milliseconds. </dd></dl>

<p>References <a class="el" href="group__Utils.html#gad443945ba007cd32410dcee65fa3c8f8">SOL_MSEC_PER_SEC</a>, and <a class="el" href="group__Utils.html#gafc59dcf2bc73c7064daf59a26fa65114">SOL_NSEC_PER_MSEC</a>.</p>

<p>Referenced by <a class="el" href="sol-glib-integration_8h.html#a0da04329ee258220d04a8b3aa9d40fdc">_sol_glib_integration_source_get_next_timeout()</a>.</p>

</div>
</div>
<a class="anchor" id="ga57ce4e370b335210cfc9f5b11c282c28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct timespec sol_util_timespec_get_current </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the current time (Monotonic). </p>
<dl class="section return"><dt>Returns</dt><dd>The current time represented in <code>struct</code> timespec. </dd></dl>

<p>Referenced by <a class="el" href="message-digest_8c.html#a5366c50e85344eaf247246178b11bd5b">print_time()</a>, and <a class="el" href="message-digest_8c.html#a8f65ca9f5a72be7fe776126fc632f8a9">startup()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0000c794612dcaec7bfec8a10627576d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sol_util_timespec_get_realtime </td>
          <td>(</td>
          <td class="paramtype">struct timespec *&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the current time (System-wide clock). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Variable used to store the time.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, or -1 for failure (in which case errno is set appropriately). </dd></dl>

</div>
</div>
<a class="anchor" id="ga8e029d247d32dd0d079d2e00f468cc9b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void sol_util_timespec_sub </td>
          <td>(</td>
          <td class="paramtype">const struct timespec *&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timespec *&#160;</td>
          <td class="paramname"><em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timespec *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts two time values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t1</td><td>First time value used on operation. </td></tr>
    <tr><td class="paramname">t2</td><td>Second time value used on operation. </td></tr>
    <tr><td class="paramname">result</td><td>Variable used to store the subtraction's result. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group__Utils.html#ga1fb4b46fdbc848b218900018782af213">SOL_NSEC_PER_SEC</a>.</p>

<p>Referenced by <a class="el" href="message-digest_8c.html#a5366c50e85344eaf247246178b11bd5b">print_time()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0ee8d069432806f014f8770900ec1f80"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void sol_util_timespec_sum </td>
          <td>(</td>
          <td class="paramtype">const struct timespec *&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timespec *&#160;</td>
          <td class="paramname"><em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timespec *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sum two time values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t1</td><td>First time value used on operation. </td></tr>
    <tr><td class="paramname">t2</td><td>Second time value used on operation. </td></tr>
    <tr><td class="paramname">result</td><td>Variable used to store the sum's result. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group__Utils.html#ga1fb4b46fdbc848b218900018782af213">SOL_NSEC_PER_SEC</a>.</p>

</div>
</div>
<a class="anchor" id="ga9e1b201ade38f1cc2df0b58980eae5f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sol_util_uint32_mul </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>op2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply two values checking for overflow. </p>
<p>This function multiplies two variables of the type <code>int64_t</code> and check if this operation causes an overflow.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op1</td><td>First operation's operator. </td></tr>
    <tr><td class="paramname">op2</td><td>Second operation's operator. </td></tr>
    <tr><td class="paramname">out</td><td>Variable used to store the result.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0</code> on success, error code (always negative) otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga772ad9098c47ae26b734d38706be9690"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sol_util_uint64_add </td>
          <td>(</td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>op2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add two values checking for overflow. </p>
<p>This function add two variables of the type <code>uint64_t</code> and check if this operation causes an overflow.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op1</td><td>First operation's operator. </td></tr>
    <tr><td class="paramname">op2</td><td>Second operation's operator. </td></tr>
    <tr><td class="paramname">out</td><td>Variable used to store the result.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0</code> on success, error code (always negative) otherwise.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Utils.html#ga1fff2785485bc562c342fcbba51a183a" title="Add two values checking for overflow. ">sol_util_size_add</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga159157c3fcc383372a10d1cbb8c1cd1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sol_util_uint64_mul </td>
          <td>(</td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>op2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply two values checking for overflow. </p>
<p>This function multiply two unsigned variables of the type <code>uint64_t</code> and check if this operation causes an overflow.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op1</td><td>First operation's operator. </td></tr>
    <tr><td class="paramname">op2</td><td>Second operation's operator. </td></tr>
    <tr><td class="paramname">out</td><td>Variable used to store the result.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0</code> on success, error code (always negative) otherwise.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Utils.html#gafc6e58baced31712555921506ef15b60" title="Multiply two values checking for overflow. ">sol_util_int64_mul</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gafc7df6638697e10b7c02e5759ef2736c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sol_util_unescape_quotes </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a>&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsol__buffer.html">sol_buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unescape a string removing quotes from it. </p>
<p>This function will unescape single quotes (\') and double quotes (") from the slice, it will also remove single and double quotes from the string if they are not escaped. Trying to unescape a character that is not a single quote or double quote it is also considered an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>The slice to be escaped </td></tr>
    <tr><td class="paramname">buf</td><td>- The buffer to hold the unescaped string - It will be initialized by this function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga739423811b1b2bca8dc71e925ccd09aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t sol_util_unicode_code_from_utf8 </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buf_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>bytes_read</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a utf-8 character to unicode code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Buffer with the utf-8 representation of the unicode character. </td></tr>
    <tr><td class="paramname">buf_len</td><td>The buffer length. </td></tr>
    <tr><td class="paramname">bytes_read</td><td>Optional pointer to variable to write number of bytes read from buf.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The code from unicode table of the character in 'buf' or a negative number on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga83d5b9e4ac3f4e96cf3b0df7d1c8edd3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t sol_util_utf8_from_unicode_code </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buf_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>unicode_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert from unicode code to utf-8 string. </p>
<p>Write at string buf the bytes needed to represent the unicode charater informed as utf-8. One to four characters will be written on success. No character is written on error.</p>
<dl class="section note"><dt>Note</dt><dd><b>no</b> trailing null '\0' is added!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Buffer to write the utf-8 representation of the unicode character </td></tr>
    <tr><td class="paramname">buf_len</td><td>The buffer length </td></tr>
    <tr><td class="paramname">unicode_code</td><td>Code from unicode table of the character to be converted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written in 'buf' or a negative number on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7524f20e61d21446bec34f910b426467"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sol_util_uuid_gen </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>upcase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>with_hyphens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>id</em>[SOL_STATIC_ARRAY_SIZE(37)]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a new universally unique identifier (UUID) string. </p>
<p>The generated string is 16 bytes-long (128 bits) long and conforms to v4 UUIDs (generated from random—or pseudo-random—numbers).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upcase</td><td>Whether to generate the UUID in upcase or not </td></tr>
    <tr><td class="paramname">with_hyphens</td><td>Format the resulting UUID string with hyphens (e.g. "de305d54-75b4-431b-adb2-eb6b9e546014") or without them. </td></tr>
    <tr><td class="paramname">id</td><td>Where to store the generated id. It's 37 bytes in lenght so it accomodates the maximum lenght case &ndash; 2 * 16 (chars) + 4 (hyphens) + 1 (\0)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative error code otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa45cf62af8d30b956e1fb12e61f647d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sol_util_uuid_str_valid </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a given universally unique identifier (UUID), in string form, is valid. </p>
<p>All upcase/downcase, hyphenated/non-hyphenated cases are included.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The given UUID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if it's valid, <code>false</code> otherwise. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
